<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>发现镓</title>
  
  <subtitle>fancyga ≈ 发现镓</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.fancyga.com/"/>
  <updated>2023-08-15T03:29:00.000Z</updated>
  <id>http://www.fancyga.com/</id>
  
  <author>
    <name>发现镓</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构之六</title>
    <link href="http://www.fancyga.com/2023/08/15/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%85%AD/"/>
    <id>http://www.fancyga.com/2023/08/15/架构之六/</id>
    <published>2023-08-15T03:29:00.000Z</published>
    <updated>2023-08-15T03:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数据库设计分为哪几个阶段？"><a href="#数据库设计分为哪几个阶段？" class="headerlink" title="数据库设计分为哪几个阶段？"></a>数据库设计分为哪几个阶段？</h5><a id="more"></a><ol><li>用户需求分析</li></ol><p>采用数据流图对功能、性能等进行分析进行分析。</p><ol start="2"><li>概念结构设计</li></ol><p>建立概念模型，即E-R图。</p><ol start="3"><li>逻辑结构设计</li></ol><p>将E-R图转化为关系模式。</p><ol start="4"><li>物理结构设计</li></ol><p>是逻辑模型在计算机中具体的实现方案。</p><ol start="5"><li>数据库实施阶段</li></ol><p>组织数据入库，并进行试运行。</p><ol start="6"><li>数据库运行和维护阶段</li></ol><p>对系统进行评价修改。</p><h5 id="给定关系模式R，其中，属性集U-A、B、C、D、E-。函数依赖集F-AC→B-B→DE-。关系R（）且分别有（）。"><a href="#给定关系模式R，其中，属性集U-A、B、C、D、E-。函数依赖集F-AC→B-B→DE-。关系R（）且分别有（）。" class="headerlink" title="给定关系模式R，其中，属性集U={A、B、C、D、E}。函数依赖集F={AC→B,B→DE}。关系R（）且分别有（）。"></a>给定关系模式R，其中，属性集U={A、B、C、D、E}。函数依赖集F={AC→B,B→DE}。关系R（）且分别有（）。</h5><p>A.只有一个候选关键字AC<br>B.只有一个候选关键字AB<br>C.有两个候选关键字AC、BC<br>D.有两个候选关键字AC、AB</p><p>A.一个非主属性和四个主属性<br>B.两个非主属性和三个主属性<br>C.三个非主属性和两个主属性<br>D.四个非主属性和一个主属性 </p><p>【答案】A、C</p><h5 id="给定关系模式R-其中U为属性集，F是U上的一组函数依赖，那么Armstrong公理系统的增广律是指（）。"><a href="#给定关系模式R-其中U为属性集，F是U上的一组函数依赖，那么Armstrong公理系统的增广律是指（）。" class="headerlink" title="给定关系模式R;其中U为属性集，F是U上的一组函数依赖，那么Armstrong公理系统的增广律是指（）。"></a>给定关系模式R;其中U为属性集，F是U上的一组函数依赖，那么Armstrong公理系统的增广律是指（）。</h5><p>A.若X→Y，X→Z，则X→YZ为F所蕴涵<br>B.若X→Y，WY→Z，则XW→Z为F所蕴涵<br>C.若X→Y，Y→Z为F所蕴涵，则X→Z为F所蕴涵<br>D.若X→Y，为F所蕴涵，且Z⊆U,则XZ→YZ为F所蕴涵</p><p>【答案】D</p><h5 id="某商场商品数据库的商品关系模式P-商品代码，商品名称，供应商，联系方式，库存量-，函数依赖集F-商品代码→商品名称，-商品代码，供应商-→库存量，供应商→联系方式-。商品关系模式P达到（）。"><a href="#某商场商品数据库的商品关系模式P-商品代码，商品名称，供应商，联系方式，库存量-，函数依赖集F-商品代码→商品名称，-商品代码，供应商-→库存量，供应商→联系方式-。商品关系模式P达到（）。" class="headerlink" title="某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到（）。"></a>某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到（）。</h5><p>A．1NF  B．2NF  C．3NF  D．BCNF</p><p>【答案】A</p><p>#####【2014年真题】计算机采用分级存储体系的主要目的是为了</p><p>A．解决主存容量不足的问题<br>B．提高存储器读写可靠性<br>C. 提高外设访问效率<br>D．解決存储的容量、价格和速度之间的矛盾</p><p>【答案】C -&gt; B</p><p>本题考查计算机系统基础知知识，接近 CPU 的存储器容量更小、速度更快、成本更高，辅存容量大、速度慢，价格低。</p><p>采用分级存储体系的目的是解决存储的容量、价格和速度之间的矛盾。</p><p>#####【2015年真题】下列说法中正确的是？</p><p>A．半双工总线只在一个方向上传输信息，全双工总线可在两个方向上轮流传输信息。<br>B. 半双工总线只在一个方向上传输信息，全双工总线可在两个方向上同时传输信息。<br>C．半双工总线可在两个方向上轮流传输信息，全双工总线可在两个方向上同时传输信息。<br>D．半双工总线可在两个方向上同时传输信息，全双工总线可在两个方向上轮流传输信息。</p><p>【答案】B -&gt; C B属于单工。</p><p>#####【2015年真题】假如有3块容量是80G的硬盘做RAID5阵列，则这个RAID5的容量是（），而如果有2块80G和1块40G的盘，此时RAID5的容量是（）。</p><p>(1) A. 240G B. 160G C. 80G D. 40G<br>(2) A. 40G B. 80G C. 160G D. 200G</p><p>【答案】 B、B</p><p>#####【2017年真题】某计算机系统采用5级流水线结构执行指令，设每条指令的执行由取指令（2t）、分析指令（1t）、取操作数（3t）、运算（1t）和写回结果（2t）组成，并分别用5个子部完成，该流水线的最大吞吐率为（）；若连续向流水线输入10条指令，则该流水线的加速比为（）。</p><p>(1) A. 1/9t B. 1/3t C. 1/2t D. 1/t<br>(1) A. 1:10 B. 2:1 C. 5:2 D. 3:1</p><p>【答案】 B、C</p><p>计算机流水线周期为最慢指令执行的时间。流水线执行时间=首条指令执行时间+（指令总数-1）* 流水线周期。</p><p>流水线吞吐率=任务数/完成时间。</p><p>流水线加速比=不采用流水线的执行时间/采用流水线的执行时间。</p><p>流水线吞吐率=n/(2t+1t+3t+1t+2t+(n-1)*3t)，可以看到当n趋近无穷大时，这个数就是1/3t。</p><p>当有10个指令时，不采用流水线，为（2t+1t+3t+1t+2t)<em>10。采用流水线为（2t+1t+3t+1t+2t) + 3t</em>9。</p><p>故加速比可以算出来为：90t / 36t = 15 / 6 = 5 / 2。</p><p>#####【2017年真题】DMA（直接存储器访问）工作方式是在（）之间建立起直接的数据通路。</p><p>A. CPU与外设<br>B. CPU与主存<br>C. 主存和外设<br>D. 外设与外设</p><p>【答案】B -&gt; C</p><p>直接主存存取 (Direct Memory Access，DMA) 是指数据在主存与 I/O 设备间的直接成块传送。<br>即在主存与 I/O 设备间传送数据块的过程中，不需要 CPU 作任何干涉，只需在过程开始启动 (即向设备发出”传送一块数据”的命令)与过程结束(CPU 通过轮询或中断得知过程是否结束和下次操作是否准备就绪) 时由CPU 进行处理，实际操作由 DMA 硬件直接完成，CPU 在传送过程中可做其它事情。</p><h5 id="【2017年真题】RISC（精简指令系统计算机）的特点不包括："><a href="#【2017年真题】RISC（精简指令系统计算机）的特点不包括：" class="headerlink" title="【2017年真题】RISC（精简指令系统计算机）的特点不包括："></a>【2017年真题】RISC（精简指令系统计算机）的特点不包括：</h5><p>A. 指令长度固定，指令种类尽量少<br>B. 寻址方式尽量丰富，指令功能尽可能强<br>C. 增加寄存器数目，以减少访存次数<br>D. 用硬布线电路实现指令解码，以尽快完成指令译码</p><p>【答案】B</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;数据库设计分为哪几个阶段？&quot;&gt;&lt;a href=&quot;#数据库设计分为哪几个阶段？&quot; class=&quot;headerlink&quot; title=&quot;数据库设计分为哪几个阶段？&quot;&gt;&lt;/a&gt;数据库设计分为哪几个阶段？&lt;/h5&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.fancyga.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.fancyga.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构之五</title>
    <link href="http://www.fancyga.com/2023/08/13/%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%94/"/>
    <id>http://www.fancyga.com/2023/08/13/架构之五/</id>
    <published>2023-08-13T09:29:00.000Z</published>
    <updated>2023-08-13T09:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2022年案例和论文题"><a href="#2022年案例和论文题" class="headerlink" title="2022年案例和论文题"></a>2022年案例和论文题</h2><a id="more"></a><h3 id="案例题"><a href="#案例题" class="headerlink" title="案例题"></a>案例题</h3><h4 id="试题一（必答）"><a href="#试题一（必答）" class="headerlink" title="试题一（必答）"></a>试题一（必答）</h4><p>阅读以下关于软件架构设计与评估的叙述，在答题纸上回答问题1和问题2。</p><p>【说明】</p><p>某电子商务公司拟升级其会员与促销管理系统，向用户提供个性化服务，提高用户的粘性。<br>在项目立项之初，公司领导层一致认为本次升级的主要目标是提升会员管理方式的灵活性，由于当前用户规模不大，业务也相对简单，系统性能方面不做过多考虑。<br>新系统除了保持现有的四级固定会员制度外，还需要根据用户的消费金额、偏好、重复性等相关特征动态调整商品的折扣力度，并支持在特定的活动周期内主动筛选与活动主题高度相关的用户集合，提供个性化的打折促销活动。</p><p>在需求分析与架构设计阶段，公司提出的需求和质量属性描述如下：</p><p>（a）管理员能够在页面上灵活设置折扣力度规则和促销活动逻辑，设置后即可生效；</p><p>（b）系统应该具备完整的安全防护措施，支持对恶意行为进行检测与报警；</p><p>（c）在正常负载情况下，系统应在0.3秒内对用户的界面操作请求进行响应；</p><p>（d）用户名是系统唯一标识，要求以字母开头，由数字和字母组合而成，长度不少于6个字符；</p><p>（e）在正常负载情况下，用户支付商品费用后在3秒内确认订单支付信息；</p><p>（f）系统主站点电力中断后，应在5秒内将请求重定向到备用站点；</p><p>（g）系统支持横向存储扩展，要求在2人天内完成所有的扩展与测试工作；</p><p>（h）系统宕机后，需要在10秒内感知错误，并自动启动热备份系统；</p><p>（i）系统需要内置接口函数，支持开发团队进行功能调试与系统诊断；</p><p>（j）系统需要为所有的用户操作行为进行详细记录，便于后期查阅与审计；</p><p>（k）支持对系统的外观进行调整和配置，调整工作需要在4人天内完成。</p><p>在对系统需求、质量属性描述和架构特性进行分析础上，系统架构师给出了两种候选的架构设计方案，公司目前正在组织相关专家对系统架构进行评估。</p><p>【问题1】（12分）</p><p>在架构评估过程中，质量属性效用树（utility tree）是对系统质量属性进行识别和优先级排序的重要工具。<br>请将合适的质量属性名称填入图1-1中（1）、（2）白处，并选择题干描述的（a）～（k）填入（3）～（6）空白处，完成该系统的效用树。</p><img src="https://images.weserv.nl/?url=https://pics7.baidu.com/feed/54fbb2fb43166d2225fdc876d3d558fb9252d249.jpeg" class="full-image"><p>【答】</p><ol><li>安全性、可修改性</li><li>e、j、h、k</li></ol><p>【问题2】（13分）</p><p>针对该系统的功能，李工建议采用面向对象的架构风格，将折扣力度计算和用户筛选分别封装为独立对象，通过对象调用实现对应的功能；<br>王工则建议采用解释器（interpreters）架构风格，将折扣力度计算用户筛选条件封装为独立的规则，通过解释规则实现对应的功能。<br>请针对系统的主要功能，从折扣规则可修改性、个性化折扣定义灵活性和系统性能三个方面对这两种架构风格进行比较与分析，并指出该系更适合采用哪种架构风格。</p><p>【答】</p><p>对于可修改性，</p><h4 id="试题二（四选二之一）"><a href="#试题二（四选二之一）" class="headerlink" title="试题二（四选二之一）"></a>试题二（四选二之一）</h4><p>【说明】</p><p>煤炭生产是国民经济发展的主要领域之一，其煤矿的安全非常重要。某能源企业拟开发一套煤矿建设项目安全预警系统，以保护煤矿建设项目从业人员生命安全。本系统的主要功能包括如下（a）～（h）所述。</p><p>（a）项目信息维护</p><p>（b）影响因素录入</p><p>（c）关联事故录入</p><p>（d）安全评价得分</p><p>（e）项目指标预警分析</p><p>（f）项目指标填报</p><p>（g）项目指标审核</p><p>（h）项目指标确认</p><p>【问题1】（9分）</p><p>王工根据煤矿建设项目安全预警系统的功能设计完成了系统的数据流图，如图2-1所示。请使用题干中描述的功能（a）～（h），补充完善空（1）～（6）处的内容，并简要介绍数据流图在分层细化过程中遵循的数据平衡原则。</p><p>【问题2】（9分）</p><p>请根据【问题1】中数据流图表示的相关信息，补充完善煤矿建设项目安全预警系统总体E-R图（见图2-2）中实体（1）～（6）的具体内容，将正确答案填在答题纸上。</p><p>【问题3】</p><p>数据流图分析阶段：建立系统的功能模型，从而完成需求分析。</p><p>数据流图设计阶段：为模块划分与模块之间接口设计提供依据。</p><p>数据字典在分析与设计阶段的作用为：</p><p>是所有人员工作的依据，统一的标准。它可以确保数据在系统中的完整性和一致性。</p><p>具体作用包括：按各种要求列表、相互参照、由描述内容检索名称、一致性检验和完整性检验。</p><h4 id="试题四（四选二之一）"><a href="#试题四（四选二之一）" class="headerlink" title="试题四（四选二之一）"></a>试题四（四选二之一）</h4><p>【说明】</p><p>某大型电商平台建立了一个在线B2B商店系统，并在全国多地建设了货物仓储中心，通过提前备货的方式来提高货物的运送效率。但是在运营过程中，发现会出现很多跨仓储中心调货从而延误货物运送的情况。为此，该企业计划新建立一个全国仓储货物管理系统，在实现仓储中心常规管理功能之外，通过对在线B2B商店系统中订单信息进行及时的分析和挖掘，并通过大数据分析预测各地仓储中心中各类货物的配置数量，从而提高运送效率，降低成本。</p><p>当用户通过在线B2B商店系统选购货物时，全国仓储货物管理系统会通过该用户所在地址、商品类别以及仓储中心的货物信息和地址，实时为用户订单反馈货物起运地（某仓储中心）并预测送达时间。反馈送达时间的响应时间应小于1秒。</p><p>为满足反馈送达时间功能的性能要求，设计团队建议在全国仓储货物管理系统中采用数据缓存集群的方式，将仓储中心基本信息、商品类别以及库存数量放置在内存的缓存中，而仓储中心的其它商品信息则存储在数据库系统。</p><p>【问题1】（9分）</p><p>设计团队在讨论缓存和数据库的数据一致性问题时，李工建议采取数据实时同步更新方案，而张工则建议采用数据异步准实时更新方案。</p><p>请用200字以内的文字，简要介绍两种方案的基本思路，说明全国仓储货物管理系统应该采用哪种方案，并说明采取该方案的原因。</p><p>【问题2】（9分）</p><p>随着业务的发展，仓储中心以及商品的数量日益增加，需要对集群部署多个缓存节点，提高缓存的处理能力。李工建议采用缓存分片方法，把缓存的数据拆分到多个节点分别存储，减轻单个缓存节点的访问压力，达到分流效果。</p><p>缓存分片方法常用的有哈希算法和一致性哈希算法，李工建议采用一致性哈希算法来进行分片。请用200字以内的文字简要说明两种算法的基本原理，并说明李工采用一致性哈希算法的原因。</p><p>【问题3】（7分）</p><p>全国仓储货物管理系统开发完成，在运营一段时间后，系统维护人员发现大量黑客故意发起非法的商品送达时间查询请求，造成了缓存击穿。张工建议尽快采用布隆过滤器方法解决。请用200字以内的文字解释布隆过滤器的工作原理和优缺点。</p><h4 id="试题五（四选二之一）"><a href="#试题五（四选二之一）" class="headerlink" title="试题五（四选二之一）"></a>试题五（四选二之一）</h4><p>某公司拟开发一套基于边缘计算的智能门禁系统，用于如园区、新零售、工业现场等存在来访、被访业务的场景。来访者在来访前，可以通过线上提前预约的方式将自己的个人信息记录在后台，被访者在系统中通过此请求后，来访者在到访时可以直接通过”刷脸”<br>的方式通过门禁，无需做其他验证。此外，系统的管理员可对正在运行的门禁设备进行管理。</p><p>基于项目需求，该公司组建项目组，召开了项目讨论会。会上，张工根据业务需求并结合边缘计算的思想，提出本系统可由访客注册模块、模型训练模块、端侧识别模块与设备调度平台模块等四项功能组成。李工从技术层面提出该系统可厂使用Flask框架与SSM框架为基础来开发后台服务器，将开发好的系统通过Docker进行部署，并使用MQTT协议对Docker进行管理。</p><p>【问题1】(5分)</p><p>MQTT协议在工业物联网中得到广泛的应用，请用300字以内的文字简要说明MQTT协议。</p><p>【问题2】 (14分)</p><p>在会议上，张工对功能模块进行了更进一步的说明：访客注册模块用于来访者提交申请与被访者确认申请，主要处理提交来访申请、来访申请审核业务，同时保存访客数据，为训练模块准备训练数据集；模型训练模块用于使用访客数据进行模型训练，为端侧设备的识别提供模型基础；端侧识别模块在边缘门禁设备上运行，使用训练好的模型来识别来访人员，与云端服务协作完成访客来访的完整业务；设备调度平台模块用于对边缘门禁设备进行管理，管理人员能够使用平台对边缘设备进行调度管理与状态监控，实现云端协同。</p><p>图5-1给出了基于边缘计算的智能门禁系统架构图，请结合HTTP协议和MQTT协议的特点为图5-1中(1)~(6)处选择合适的协议；并结合张工关于功能模块的描述，补充完善图5-1中(7)~(10)处的空白。</p><p>【问题3】(6分)</p><p>请用300字以内的文字，从数据通信、数据安全和系统性能等方面简要分析在传统云计算模型中引入边缘计算模型的优势。</p><img src="https://images.weserv.nl/?url=https://pics7.baidu.com/feed/f2deb48f8c5494eee764adc4b803b1f29b257eaf.webp" class="full-image"><img src="https://images.weserv.nl/?url=https://pics7.baidu.com/feed/c83d70cf3bc79f3dab57595e2f579c1d738b2928.webp" class="full-image">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2022年案例和论文题&quot;&gt;&lt;a href=&quot;#2022年案例和论文题&quot; class=&quot;headerlink&quot; title=&quot;2022年案例和论文题&quot;&gt;&lt;/a&gt;2022年案例和论文题&lt;/h2&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.fancyga.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.fancyga.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构之四</title>
    <link href="http://www.fancyga.com/2023/08/10/%E6%9E%B6%E6%9E%84%E4%B9%8B%E5%9B%9B/"/>
    <id>http://www.fancyga.com/2023/08/10/架构之四/</id>
    <published>2023-08-10T09:29:00.000Z</published>
    <updated>2023-08-10T09:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数据库的三级模式是哪三级？"><a href="#数据库的三级模式是哪三级？" class="headerlink" title="数据库的三级模式是哪三级？"></a>数据库的三级模式是哪三级？</h5><p>外模式（子模式、用户模式），概念模式，内模式。</p><a id="more"></a><h5 id="在数据库的体系结构中，什么模式体现了全体数据的逻辑结构和特征，是所有用户的公共数据视图？"><a href="#在数据库的体系结构中，什么模式体现了全体数据的逻辑结构和特征，是所有用户的公共数据视图？" class="headerlink" title="在数据库的体系结构中，什么模式体现了全体数据的逻辑结构和特征，是所有用户的公共数据视图？"></a>在数据库的体系结构中，什么模式体现了全体数据的逻辑结构和特征，是所有用户的公共数据视图？</h5><p>概念模式。</p><h5 id="在数据库设计的需求分析阶段应完成包括（）在内的文档。"><a href="#在数据库设计的需求分析阶段应完成包括（）在内的文档。" class="headerlink" title="在数据库设计的需求分析阶段应完成包括（）在内的文档。"></a>在数据库设计的需求分析阶段应完成包括（）在内的文档。</h5><p>A.E-R图<br>B.关系模式<br>C.数据字典和数据流图<br>D.任务书和设计方案</p><p>答案：C</p><h5 id="RUP的特点是什么？"><a href="#RUP的特点是什么？" class="headerlink" title="RUP的特点是什么？"></a>RUP的特点是什么？</h5><p>RUP，Rational Unified Process，软件统一过程，是Rational软件公司创造的软件工程方法。</p><p>有以下特点：</p><ol><li><p>用例驱动。RUP中的开发活动时用例驱动的，即需求分析、设计、实现和测试等活动都是用例驱动的。</p></li><li><p>以体系结构为中心。RUP中的开发活动时围绕体系结构展开的。</p></li></ol><ul><li>4+1视图</li></ul><p>围绕：</p><p>场景（用例图）</p><p>周边有：</p><p>逻辑视图（类图） —————–&gt;实现（开发）视图（包图、组件图）</p><p>进程（过程）视图（活动图）———-&gt;物理视图（部署图）  </p><ol start="3"><li>迭代与增量。RUP强调要采用迭代和增量的方式来开发软件，把整个项目开发分为多个迭代过程。</li></ol><h5 id="RUP分为哪几个阶段，每个阶段的主要任务是什么？"><a href="#RUP分为哪几个阶段，每个阶段的主要任务是什么？" class="headerlink" title="RUP分为哪几个阶段，每个阶段的主要任务是什么？"></a>RUP分为哪几个阶段，每个阶段的主要任务是什么？</h5><p>RUP把软件开发生命周期划分为多个循环，每个循环生成产品的一个新的版本，每个循环依次由4个连续的阶段组成，包括：</p><ol><li>初始化（inception）阶段：定义最终产品视图和业务模型，并确定系统范围。</li><li>细化（elaboration）阶段：设计及确定系统的体系结构，制定工作计划及资源要求。</li><li>构造（construction）阶段：构造产品并继续演进需求、体系结构、计划直至产品提交。</li><li>移交（transition）阶段：把产品提交给用户使用。</li></ol><h5 id="原型方法分为哪两个阶段？"><a href="#原型方法分为哪两个阶段？" class="headerlink" title="原型方法分为哪两个阶段？"></a>原型方法分为哪两个阶段？</h5><ol><li>原型开发阶段。</li></ol><p>软件开发人员根据用户提出的软件系统的定义，快速地开发一个原型。该原型应该包含目标系统的关键问题和反应目标系统的大致面貌，展示目标系统的全部或部分功能、性能等。</p><p>可以考虑以下3种途径：</p><ul><li>利用模拟软件系统的人机界面</li><li>真正开发一个原型</li><li>找来一个或几个正在运行的类似的软件进行比较</li></ul><ol start="2"><li>目标软件开发阶段。</li></ol><p>在征求用户对原型的意见后对原型进行修改完善，确认软件系统的需求并达到一致的理解，进一步开发实际系统。</p><h5 id="开发的哪种方法是不同项目，采用不同策略？"><a href="#开发的哪种方法是不同项目，采用不同策略？" class="headerlink" title="开发的哪种方法是不同项目，采用不同策略？"></a>开发的哪种方法是不同项目，采用不同策略？</h5><p>敏捷开发方法，其中水晶方法认为每个不同的项目都有一套不同的策略、约定和方法论。</p><h5 id="指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能，是属于哪一种内聚？"><a href="#指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能，是属于哪一种内聚？" class="headerlink" title="指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能，是属于哪一种内聚？"></a>指模块内执行若干个逻辑上相似的功能，通过参数确定该模块完成哪一个功能，是属于哪一种内聚？</h5><p>逻辑内聚</p><p>模块的内聚从低到高排序</p><table><thead><tr><th>内聚类型</th><th style="text-align:right">描述</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td>偶然内聚</td><td style="text-align:right">指一个模块内的各处理元素之间<strong>没有任何联系</strong>，完全是通过上级模块的控制和调用来实现的</td><td style="text-align:center">比如某函数内把一堆不相关的操作都放了进来</td></tr><tr><td>逻辑内聚</td><td style="text-align:right">指模块内执行若干个<strong>逻辑上相似</strong>的功能，通过参数确定该模块完成哪一个功能</td><td style="text-align:center">比如某加法函数内，A、B、C三个代码块分别代表int、float、double的加法。这些代码块之所以聚在一起，只是它们都是为了完成加法运算而已</td></tr><tr><td>时间内聚</td><td style="text-align:right">指把需要<strong>同时执行</strong>的动作组合在一起形成的模块</td><td style="text-align:center">比如某函数内A、B、C三个代码块需要保证原子性，三者执行不容分割。</td></tr><tr><td>过程内聚</td><td style="text-align:right">指一个模块完成多个任务，这些任务必须按照<strong>指定的过程执行</strong></td><td style="text-align:center">比如某数据库操作函数，需要先连接JDBC获得connection对象，然后才能创建Statement对象，最后才能执行sql语句</td></tr><tr><td>通信内聚</td><td style="text-align:right">指模块内的所有处理元素都在<strong>同一个数据结构</strong>上操作，或者各处理使用相同的输入数据或者产生相同的输出数据</td><td style="text-align:center">比如某函数内A、B、C三个代码块，都会对同一个全局变量来进行操作和更新</td></tr><tr><td>顺序内聚</td><td style="text-align:right">指一个模块中的各个处理元素都密切相关于同一功能且<strong>必须顺序执行</strong>，前一功能元素的输出就是下一功能元素的输入</td><td style="text-align:center">比如某函数内的A、B、C三个代码块顺序固定，A的输出是B的输入，B的输出是C的输入</td></tr><tr><td>功能内聚</td><td style="text-align:right">指模块内的所有元素共同作用<strong>完成一个功能</strong>， 缺一不可</td><td style="text-align:center">比如某排序函数内，包含的所有代码不能缺少任意一行代码，否则整个排序功能失效</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;数据库的三级模式是哪三级？&quot;&gt;&lt;a href=&quot;#数据库的三级模式是哪三级？&quot; class=&quot;headerlink&quot; title=&quot;数据库的三级模式是哪三级？&quot;&gt;&lt;/a&gt;数据库的三级模式是哪三级？&lt;/h5&gt;&lt;p&gt;外模式（子模式、用户模式），概念模式，内模式。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.fancyga.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.fancyga.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构之三</title>
    <link href="http://www.fancyga.com/2023/08/07/%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%B8%89/"/>
    <id>http://www.fancyga.com/2023/08/07/架构之三/</id>
    <published>2023-08-07T09:29:00.000Z</published>
    <updated>2023-08-07T09:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="反规范化设计保证数据的一致性方法主要有哪些？"><a href="#反规范化设计保证数据的一致性方法主要有哪些？" class="headerlink" title="反规范化设计保证数据的一致性方法主要有哪些？"></a>反规范化设计保证数据的一致性方法主要有哪些？</h5><p>触发器、事务保证、应用保证、批处理脚本。</p><a id="more"></a><h5 id="MySQL主从数据库之间通过binary-log（二进制日志）进行数据的同步。具体过程是什么？"><a href="#MySQL主从数据库之间通过binary-log（二进制日志）进行数据的同步。具体过程是什么？" class="headerlink" title="MySQL主从数据库之间通过binary log（二进制日志）进行数据的同步。具体过程是什么？"></a>MySQL主从数据库之间通过binary log（二进制日志）进行数据的同步。具体过程是什么？</h5><ol><li>从库连接主库，请求binlog同步;</li><li>主节点启动一个线程（dump）读取binlog;</li><li>发送binlog中的日志信息；</li><li>从库将接到的日志信息存放到relay log;</li><li>从库读取relay log中的日志信息；</li><li>将数据库更新事件在存储引擎中执行。</li></ol><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/b6630a788de642f7bb444d6496c59e43.png" class="full-image"><h5 id="binlog-有哪三种模式？"><a href="#binlog-有哪三种模式？" class="headerlink" title="binlog 有哪三种模式？"></a>binlog 有哪三种模式？</h5><p>① 基于SQL语句（Statement）的复制，每一条更新的语句（insert、update、delete）都会记录在binlog中， 进而同步到从库的relay log中，被从库的SQL线程取出来，回放执行。</p><p>该模式的优点是binlog的日志量可能会比较少，比如一个涉及行数为1000行的update语句：同步这一个语句，就同步了1000行的数据。</p><p>缺点是：同步的SQL语句里如果含有绑定本地变量的 函数、关键字时，可能造成主从不一致的情况。比如SQL语句中有time函数，如果主从数据库的 服务器时间不是精确相等，就会造成结果不一致。</p><p>② 基于行（ROW）的复制，不记录SQL语句，只记录了哪个记录更新前和更新后的数据，可以保证主从之间数据绝对相同。</p><p>缺点是：上个例子的1条SQL更新1000行的数据无法再偷懒，必须原原本本同步1000行的数据量。</p><p>③ 混合（MIX）复制：以上两种模式的混合，选取两者的优点。对于有绑定本地特性、评估可能造成主从不一致的SQL语句，则自动选用ROW，其他的选择STATEMENT。</p><h5 id="binlog的复制方式中那种同步的SQL语句里如果含有绑定本地变量的函数、关键字时，可能造成主从不一致的情况？"><a href="#binlog的复制方式中那种同步的SQL语句里如果含有绑定本地变量的函数、关键字时，可能造成主从不一致的情况？" class="headerlink" title="binlog的复制方式中那种同步的SQL语句里如果含有绑定本地变量的函数、关键字时，可能造成主从不一致的情况？"></a>binlog的复制方式中那种同步的SQL语句里如果含有绑定本地变量的函数、关键字时，可能造成主从不一致的情况？</h5><p>基于SQL的复制。</p><h5 id="binlog的复制方式中那种不记录SQL语句，只记录了那个记录更新前和更新后的数据，可以保证主从之间数据绝对相同。"><a href="#binlog的复制方式中那种不记录SQL语句，只记录了那个记录更新前和更新后的数据，可以保证主从之间数据绝对相同。" class="headerlink" title="binlog的复制方式中那种不记录SQL语句，只记录了那个记录更新前和更新后的数据，可以保证主从之间数据绝对相同。"></a>binlog的复制方式中那种不记录SQL语句，只记录了那个记录更新前和更新后的数据，可以保证主从之间数据绝对相同。</h5><p>基于行复制。</p><h5 id="binlog的复制方式中哪种是两种模式的混合？"><a href="#binlog的复制方式中哪种是两种模式的混合？" class="headerlink" title="binlog的复制方式中哪种是两种模式的混合？"></a>binlog的复制方式中哪种是两种模式的混合？</h5><p>混合复制。</p><h5 id="MySQL主从同步的同步模式有哪几种？分别是什么？"><a href="#MySQL主从同步的同步模式有哪几种？分别是什么？" class="headerlink" title="MySQL主从同步的同步模式有哪几种？分别是什么？"></a>MySQL主从同步的同步模式有哪几种？分别是什么？</h5><p>① 全同步：</p><p>当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。</p><p>优点是：只要不是所有数据库都发生异常，就能保证数据不丢失。<br>缺点是：因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能较其他方式低一些。</p><p>② 半同步：</p><p>主库只需要等待至少一个从库节点从 Binlog 中收到该请求，并保存到 Relay Log 文件即可，主库不需要等待所有从库给主库反馈。</p><p>优点是：只需收到的一个反馈，而不是全部从库完成提交的反馈，较全同步节省了时间，同时能保证主库发生故障后，至少能从余下的1个从库上找回全部数据。<br>缺点是：降低了一致性，但权衡了一致性和性能，做出取舍。</p><p>③ 异步：</p><p>主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。</p><p>优点是：速度较快。<br>缺点是：主库如果发生问题，此时主库已经提交的事务可能并没有同步到从库上，可能导致数据丢失或不完整。</p><h5 id="引入主从复制机制所带来的好处主要是什么？"><a href="#引入主从复制机制所带来的好处主要是什么？" class="headerlink" title="引入主从复制机制所带来的好处主要是什么？"></a>引入主从复制机制所带来的好处主要是什么？</h5><ol><li>避免单点故障，提高可用性。</li><li>提高了查询效率。可以采用读写分离技术，提高数据库访问效率。</li></ol><h5 id="主从复制一般伴随着读写分离策略，请简述这个方式下主库与从库分别承担什么任务？"><a href="#主从复制一般伴随着读写分离策略，请简述这个方式下主库与从库分别承担什么任务？" class="headerlink" title="主从复制一般伴随着读写分离策略，请简述这个方式下主库与从库分别承担什么任务？"></a>主从复制一般伴随着读写分离策略，请简述这个方式下主库与从库分别承担什么任务？</h5><p>主库一般承担写操作，从库一般承担读操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;反规范化设计保证数据的一致性方法主要有哪些？&quot;&gt;&lt;a href=&quot;#反规范化设计保证数据的一致性方法主要有哪些？&quot; class=&quot;headerlink&quot; title=&quot;反规范化设计保证数据的一致性方法主要有哪些？&quot;&gt;&lt;/a&gt;反规范化设计保证数据的一致性方法主要有哪些？&lt;/h5&gt;&lt;p&gt;触发器、事务保证、应用保证、批处理脚本。&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.fancyga.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.fancyga.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构之二</title>
    <link href="http://www.fancyga.com/2023/08/03/%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%BA%8C/"/>
    <id>http://www.fancyga.com/2023/08/03/架构之二/</id>
    <published>2023-08-03T15:29:00.000Z</published>
    <updated>2023-08-03T15:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="HTTP协议与HTTPS协议对应的缺省端口号分别是什么？"><a href="#HTTP协议与HTTPS协议对应的缺省端口号分别是什么？" class="headerlink" title="HTTP协议与HTTPS协议对应的缺省端口号分别是什么？"></a>HTTP协议与HTTPS协议对应的缺省端口号分别是什么？</h5><a id="more"></a><ul><li>HTTP：80</li><li>HTTPS：443</li></ul><h5 id="信息安全的三元组是什么？"><a href="#信息安全的三元组是什么？" class="headerlink" title="信息安全的三元组是什么？"></a>信息安全的三元组是什么？</h5><ul><li>机密性：信息不被泄露给未授权的个人、实体和过程或不被其使用的特性。</li><li>完整性：保护资产的正确和完整的特性。</li><li>可用性：得到授权的实体在需要时可访问数据，即攻击者不能占用所有的资源而阻碍授权者的工作。</li></ul><h5 id="假冒身份是属于主动还是被动攻击？"><a href="#假冒身份是属于主动还是被动攻击？" class="headerlink" title="假冒身份是属于主动还是被动攻击？"></a>假冒身份是属于主动还是被动攻击？</h5><p>属于主动型攻击。</p><h5 id="在信息安全的范围中什么是信息系统安全的首要问题，是信息系统安全的物质基础？"><a href="#在信息安全的范围中什么是信息系统安全的首要问题，是信息系统安全的物质基础？" class="headerlink" title="在信息安全的范围中什么是信息系统安全的首要问题，是信息系统安全的物质基础？"></a>在信息安全的范围中什么是信息系统安全的首要问题，是信息系统安全的物质基础？</h5><p>设备安全。</p><p>信息安全的范围分类如下：</p><ul><li>设备安全：信息系统安全的首要问题，是信息系统安全的物质基础。</li><li>数据安全：采取措施确保数据免受未授权 的泄露、篡改和毁坏。</li><li>内容安全：信息安全在政治、法律、道德层次上的要求。</li><li>行为安全：信息系统的服务功能是指最终通过行为提供给用户，确保信息系统的行为安全，才能最终确保系统的信息安全。</li></ul><h5 id="哪种加密算法适合大数据量（明文）加密，加密速度快？"><a href="#哪种加密算法适合大数据量（明文）加密，加密速度快？" class="headerlink" title="哪种加密算法适合大数据量（明文）加密，加密速度快？"></a>哪种加密算法适合大数据量（明文）加密，加密速度快？</h5><p>对称加密算法，又叫私钥加密算法，加密和解密的秘钥相同。</p><h5 id="某计算机系统页面大小为4K，进程P1的页面变换表如下图示，看P1要访问数据的逻辑地址为十六进制1B1AH，那么该逻辑地址经过变换后，其对应的物理地址应为十六进制是什么。"><a href="#某计算机系统页面大小为4K，进程P1的页面变换表如下图示，看P1要访问数据的逻辑地址为十六进制1B1AH，那么该逻辑地址经过变换后，其对应的物理地址应为十六进制是什么。" class="headerlink" title="某计算机系统页面大小为4K，进程P1的页面变换表如下图示，看P1要访问数据的逻辑地址为十六进制1B1AH，那么该逻辑地址经过变换后，其对应的物理地址应为十六进制是什么。"></a>某计算机系统页面大小为4K，进程P1的页面变换表如下图示，看P1要访问数据的逻辑地址为十六进制1B1AH，那么该逻辑地址经过变换后，其对应的物理地址应为十六进制是什么。</h5><table><thead><tr><th style="text-align:left">页号</th><th style="text-align:right">物理块号</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:right">1</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">6</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">3</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">8</td></tr></tbody></table><p>A. 1B1AH B.3B1AH C.6B1AH D.8B1AH</p><p>技巧：看答案都是以B1A结尾，猜到这个是快大小，后面偏移一样。然后1对应6，故选C。</p><p>详细解答：$4K = 4 * 1024 = 10^12 = 16^3$，故十六进制的第四位刚好就是页的单位，故1B1AH刚好是逻辑1页，B1AH为页内偏移，转到物理块根据表可以知是物理块6，因为物理地址也是4K大小，逻辑地址的偏移和物理地址的偏移其实是一样的，故物理地址为6B1AH。</p><h5 id="在实时操作系统中，两个任务并发执行，一个任务要等待另一个任务发来消息，或建立某个条件后再向前执行，这种制约性合作关系被称为任务的什么？"><a href="#在实时操作系统中，两个任务并发执行，一个任务要等待另一个任务发来消息，或建立某个条件后再向前执行，这种制约性合作关系被称为任务的什么？" class="headerlink" title="在实时操作系统中，两个任务并发执行，一个任务要等待另一个任务发来消息，或建立某个条件后再向前执行，这种制约性合作关系被称为任务的什么？"></a>在实时操作系统中，两个任务并发执行，一个任务要等待另一个任务发来消息，或建立某个条件后再向前执行，这种制约性合作关系被称为任务的什么？</h5><p>本题考查实时操作系统基础知识。 由于资源共享与进程合作，并发执行的任务（进程）之间可能产生相互制约关系，这些制约关系可分为两类：竞争与协作。</p><p>并发进程之间的竞争关系为互斥，并发进程之间的协作关系体现为同步。 同步是因合作进程之间协调彼此的工作而控制自己的执行速度，即因相互合作，相互等待而产生的制约关系。</p><p>而互斥是进程之间竞争临界资源而禁止两个以上的进程同时进入临界区所发生的制约关系。 </p><p>题目中一个任务要等待另一个任务发来消息，或建立某个条件后再向前执行，显然体现的制约关系是任务的<strong>同步</strong>。</p><h5 id="某文件系统文件存储采用文件索引节点法。假设磁盘索引块和磁盘数据块大小均为1KB，每个文件的索引节点中有8个地址项iaddr-0-～iaddr-7-，每个地址项大小为4B，其中iaddr-0-～iaddr-5-为直接地址索引，iaddr-6-是一级间接地址索引，iaddr-7-是二级间接地址索引。如果要访问icwutil-dll文件的逻辑块号为0，则系统应采用的索引方式是？"><a href="#某文件系统文件存储采用文件索引节点法。假设磁盘索引块和磁盘数据块大小均为1KB，每个文件的索引节点中有8个地址项iaddr-0-～iaddr-7-，每个地址项大小为4B，其中iaddr-0-～iaddr-5-为直接地址索引，iaddr-6-是一级间接地址索引，iaddr-7-是二级间接地址索引。如果要访问icwutil-dll文件的逻辑块号为0，则系统应采用的索引方式是？" class="headerlink" title="某文件系统文件存储采用文件索引节点法。假设磁盘索引块和磁盘数据块大小均为1KB，每个文件的索引节点中有8个地址项iaddr[0]～iaddr[7]，每个地址项大小为4B，其中iaddr[0]～iaddr[5]为直接地址索引，iaddr[6]是一级间接地址索引，iaddr[7]是二级间接地址索引。如果要访问icwutil.dll文件的逻辑块号为0，则系统应采用的索引方式是？"></a>某文件系统文件存储采用文件索引节点法。假设磁盘索引块和磁盘数据块大小均为1KB，每个文件的索引节点中有8个地址项iaddr[0]～iaddr[7]，每个地址项大小为4B，其中iaddr[0]～iaddr[5]为直接地址索引，iaddr[6]是一级间接地址索引，iaddr[7]是二级间接地址索引。如果要访问icwutil.dll文件的逻辑块号为0，则系统应采用的索引方式是？</h5><p>每个索引块大小为1KB，每个地址项大小为4B，故每个索引块包含$1024/4=256$个地址项。根据题目，每个文件的索引节点的八个地址，前面的逻辑块号情况分别为：0~5为直接地址索引，从6开始，因为6为一级索引，根据前面，它可以扩展出256个地址索引，因此因为256+6-1=261，故iaddr[6]可表示6~261号物理块。</p><p>由于iaddr[7]是二级间接地址索引，其可表示的物理块数量为 256 * 256 = 65536。每个物理块为1KB，故可表示的文件最大长度为6 + 256 + 65536 = 65798K。</p><p>根据前面分析，0逻辑块号显然为直接索引。</p><h5 id="如果要访问icwutil-dll文件的逻辑块号为260，则系统应采用的索引方式是？"><a href="#如果要访问icwutil-dll文件的逻辑块号为260，则系统应采用的索引方式是？" class="headerlink" title="如果要访问icwutil.dll文件的逻辑块号为260，则系统应采用的索引方式是？"></a>如果要访问icwutil.dll文件的逻辑块号为260，则系统应采用的索引方式是？</h5><p>根据上面分析260属于6~261区间，属于一级间接索引。</p><h5 id="如果要访问icwutil-dll文件的逻辑块号为518，则系统应采用的索引方式是？"><a href="#如果要访问icwutil-dll文件的逻辑块号为518，则系统应采用的索引方式是？" class="headerlink" title="如果要访问icwutil.dll文件的逻辑块号为518，则系统应采用的索引方式是？"></a>如果要访问icwutil.dll文件的逻辑块号为518，则系统应采用的索引方式是？</h5><p>根据上面分析518大于261，属于二级间接索引。</p><h5 id="回忆一下你所做过的项目里是如何使用缓存技术的？是为了做读加速，还是为了做某种统计量？"><a href="#回忆一下你所做过的项目里是如何使用缓存技术的？是为了做读加速，还是为了做某种统计量？" class="headerlink" title="回忆一下你所做过的项目里是如何使用缓存技术的？是为了做读加速，还是为了做某种统计量？"></a>回忆一下你所做过的项目里是如何使用缓存技术的？是为了做读加速，还是为了做某种统计量？</h5><p>比如曾经做过的用户登录后缓存用户信息，就是为了读加速，不必每次请求数据库，减少数据库压力。</p><h5 id="思考一下什么样的项目或场景，不能使用缓存？"><a href="#思考一下什么样的项目或场景，不能使用缓存？" class="headerlink" title="思考一下什么样的项目或场景，不能使用缓存？"></a>思考一下什么样的项目或场景，不能使用缓存？</h5><p>比如实时统计的场景，不适合做缓存，因为这些数据都是实时统计会变的，做缓存无意义。</p><blockquote><p>缓存有用的场景</p></blockquote><ol><li>读密集型的应用；</li><li>存在热数据的应用；</li><li>对响应时效要求较高的应用；</li><li>一致性要求不严格；</li><li>实现分布式锁。</li></ol><blockquote><p>缓存不应使用的场景</p></blockquote><ol><li>更新较频繁的数据不宜用缓存；</li><li>对一致性要求比较高的情况；</li><li>读操作比较少的情况；</li><li>数据量比较少。</li></ol><h5 id="redis的cluster集群，内部使用了slot机制，结合”带有虚拟节点的一致性哈希”的知识，说说redis这种设计的好处。"><a href="#redis的cluster集群，内部使用了slot机制，结合”带有虚拟节点的一致性哈希”的知识，说说redis这种设计的好处。" class="headerlink" title="redis的cluster集群，内部使用了slot机制，结合”带有虚拟节点的一致性哈希”的知识，说说redis这种设计的好处。"></a>redis的cluster集群，内部使用了slot机制，结合”带有虚拟节点的一致性哈希”的知识，说说redis这种设计的好处。</h5><p>Redis的slot机制是一种数据分片机制。要明白一致性哈希的好处，首先要来了解”带有虚拟节点的哈希”，对于某个KEY，用哈希算法算出哈希值后，对节点数量取模，这样就能知道它落在哪个节点中。</p><p>这种方式当然可以完成数据分片，在节点状况都良好的时候没有问题。但如果一个节点宕机，节点数量变了，则我们的哈希取模得到值与原来的不同了，就会产生缓存失效问题。</p><p>另外一个就是当我们要扩展一个节点的时候，哈希算法同样的道理，也是产生缓存失效问题。</p><p>那一致性哈希就是解决这个问题的。相比哈希，一致性哈徐是对$2^32$取模，假设落在一个圆周上，我们将虚拟节点在圆周上均匀分布，其中，按顺时针，落在节点前面的KEY就放在该节点。</p><p>这样，当我们在圆环上增加或删除一个节点时，可以知道原来的KEY位置仍然不变，缓存数据只会影响新增或者删除节点的那段数据，而不会像前面那样全局影响，这样当新增或删除节点时，对我们的缓存数据不会造成太大的影响。</p><h5 id="缓存穿透、缓存雪崩、缓存击穿是缓存非常重要的问题，带着本节课讲到的解决方法，回顾实际项目中是如何解决的，实际所用的解决方式有什么样的不同？"><a href="#缓存穿透、缓存雪崩、缓存击穿是缓存非常重要的问题，带着本节课讲到的解决方法，回顾实际项目中是如何解决的，实际所用的解决方式有什么样的不同？" class="headerlink" title="缓存穿透、缓存雪崩、缓存击穿是缓存非常重要的问题，带着本节课讲到的解决方法，回顾实际项目中是如何解决的，实际所用的解决方式有什么样的不同？"></a>缓存穿透、缓存雪崩、缓存击穿是缓存非常重要的问题，带着本节课讲到的解决方法，回顾实际项目中是如何解决的，实际所用的解决方式有什么样的不同？</h5><p>缓存穿透：是指查询一个缓存和数据库都不存在的数据，这样每次请求都会到达数据库，然后返回空，导致数据库压力倍增。</p><p>解决缓存穿透方法：</p><ol><li>可以缓存空值（加个过期时间），这样就不必每次都去到数据库，加个过期时间是为了不能一直返回空，过一段时间更新下最新值</li><li>可以使用布隆过滤器。布隆过滤器，可以提前预判这个值到底存不存在，不存在直接返回空，避免了到达缓存和数据库。</li></ol><p>缓存击穿：是指缓存中的某个热点数据过期了，在重新载入缓存中时，大量的请求过来，都打到了数据库，这样数据库瞬间压力倍增。</p><p>解决缓存击穿方法：</p><ol><li>很简单，设置永久不过期。这样就不会有过期问题。还有一种方法就是启动定时任务去定时更新这个KEY。</li><li>使用分布式锁，这样能保证同一时刻，只有一个请求数据并设置缓存，这样后面其他请求就能拿到缓存中的值。</li></ol><p>缓存雪崩：是指大量的KEY在同一时间过期了，或者Redis宕机，这样大量的请求就会到达数据库。</p><p>解决方法：</p><p>就是避免大量的KEY再同一时间过期，可以在KEY过期时间加个随机数。</p><h5 id="如果让你设计一个分布式缓存组件，试着从以下几个方面来回答你的设计：一、如何解决分片的问题，以及分片带来的透明性的问题。二、如何解决与数据库之间的一致性问题。三、-当缓存的可用性要求较高时，如何设计？"><a href="#如果让你设计一个分布式缓存组件，试着从以下几个方面来回答你的设计：一、如何解决分片的问题，以及分片带来的透明性的问题。二、如何解决与数据库之间的一致性问题。三、-当缓存的可用性要求较高时，如何设计？" class="headerlink" title="如果让你设计一个分布式缓存组件，试着从以下几个方面来回答你的设计：一、如何解决分片的问题，以及分片带来的透明性的问题。二、如何解决与数据库之间的一致性问题。三、 当缓存的可用性要求较高时，如何设计？"></a>如果让你设计一个分布式缓存组件，试着从以下几个方面来回答你的设计：一、如何解决分片的问题，以及分片带来的透明性的问题。二、如何解决与数据库之间的一致性问题。三、 当缓存的可用性要求较高时，如何设计？</h5><blockquote><p>如何解决分片问题</p></blockquote><ol><li>每个物理节点引入多个虚拟节点，增加数据分布的均匀性，减少数据倾斜。</li><li>将每个分片的数据复制到多个节点，以提高数据的冗余和容错性。</li><li>使用一致性哈希算法，这样当节点数量变化时，只会影响到部分缓存数据。</li></ol><blockquote><p>如何解决与数据库之间的一致性问题</p></blockquote><ol><li>分布式锁，这样可以保证同一时间只有一个请求处理读写缓存，不会因并发而产生数据不一致问题。</li><li>自动过期策略：设置缓存过期时间，这样一段时间后会进行和数据库同步。</li><li>所谓的双写一致性，延迟双删，可以保证数据库和缓存读写并发的一致性问题。（具体可看<a href="http://www.fancyga.com/2023/07/07/八股之二">我之前写的文章《八股之二》</a>）</li></ol><blockquote><p>当缓存的可用性要求较高时，如何设计？</p></blockquote><p>可以利用Redis的各大模式，如：</p><ul><li>主从复制模式，有一个主节点负责写，其他多个从节点负责读，主节点上的数据会单向复制到各从节点。</li><li>哨兵模式，在主从复制模式上，增加了自动化的故障恢复功能。当主节点宕机后，会采用投票机制从从节点中选一个主节点。</li><li>集群模式，在前面两个模式有个缺点就是只有一个主节点。集群模式采用去中心化思想，没有主节点的说法，数据采用分片方式存在各个节点。对客户端来讲整个集群就是一个整体，当客户端的KEY没有在这个节点上时，会返回转向指令，转到正确节点。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;HTTP协议与HTTPS协议对应的缺省端口号分别是什么？&quot;&gt;&lt;a href=&quot;#HTTP协议与HTTPS协议对应的缺省端口号分别是什么？&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议与HTTPS协议对应的缺省端口号分别是什么？&quot;&gt;&lt;/a&gt;HTTP协议与HTTPS协议对应的缺省端口号分别是什么？&lt;/h5&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.fancyga.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.fancyga.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>架构之一</title>
    <link href="http://www.fancyga.com/2023/08/03/%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%B8%80/"/>
    <id>http://www.fancyga.com/2023/08/03/架构之一/</id>
    <published>2023-08-03T01:29:00.000Z</published>
    <updated>2023-08-03T01:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>开启此系列，为架构之常见问答，学以记录。</p><h5 id="局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？"><a href="#局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？" class="headerlink" title="局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？"></a>局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？</h5><a id="more"></a><ul><li>属性冲突<ul><li>属性域冲突：例如，零件号有的部门定义为整数，有的部门定义为字符串。</li><li>属性值冲突：例如，零件的重量有的以公斤为单位，有的以克为单位。</li></ul></li><li>结构冲突<ul><li>同一对象在不同局部中的抽象不同：例如，职工在某些局部里是实体，在另外局部里是属性。</li><li>同一实体在不同局部中的属性个数和排列次序可能不同。</li></ul></li><li>命名冲突<ul><li>名字相同意思不同。</li><li>意思相同名字不同。</li></ul></li></ul><h5 id="“同一对象在不同应用中的抽象不同，职工在某一应用中是实体，在另一应用中是属性。”这是什么冲突？"><a href="#“同一对象在不同应用中的抽象不同，职工在某一应用中是实体，在另一应用中是属性。”这是什么冲突？" class="headerlink" title="“同一对象在不同应用中的抽象不同，职工在某一应用中是实体，在另一应用中是属性。”这是什么冲突？"></a>“同一对象在不同应用中的抽象不同，职工在某一应用中是实体，在另一应用中是属性。”这是什么冲突？</h5><p>根据上题，属于结构冲突。</p><h5 id="对现实事物抽象认识的3种方法分别是什么？"><a href="#对现实事物抽象认识的3种方法分别是什么？" class="headerlink" title="对现实事物抽象认识的3种方法分别是什么？"></a>对现实事物抽象认识的3种方法分别是什么？</h5><ul><li>分类（Classification）：对现实世界的事物，按照其具有的共同特征和行为，定义一种<strong>类型</strong>。</li><li>聚集（Aggregation）：定义某一类型所具有的<strong>属性</strong>。</li><li>概括（Generalization）：由一种已知类型定义新的类型。通常，把已知类型称为超类（Superclass），新定义的类型称为子类（Subclass）。</li></ul><h5 id="给定关系模式R-lt-U-F-gt-，其中，属性集U-A、B、C、D、E-，函数依赖集F-AC-gt-B-B一DE-，关系R的主键是什么？"><a href="#给定关系模式R-lt-U-F-gt-，其中，属性集U-A、B、C、D、E-，函数依赖集F-AC-gt-B-B一DE-，关系R的主键是什么？" class="headerlink" title="给定关系模式R&lt;U,F&gt;，其中，属性集U={A、B、C、D、E}，函数依赖集F={AC-&gt;B,B一DE}，关系R的主键是什么？"></a>给定关系模式R&lt;U,F&gt;，其中，属性集U={A、B、C、D、E}，函数依赖集F={AC-&gt;B,B一DE}，关系R的主键是什么？</h5><p>主键是AC，因为AC唯一决定了该元组。</p><h5 id="设关系模式R-U-F-U-A1-A2-A3-A4-函数依赖集F-A1-gt-A2-A1-›A3-A2-gt-A4-，该关系模式属于第几范式？"><a href="#设关系模式R-U-F-U-A1-A2-A3-A4-函数依赖集F-A1-gt-A2-A1-›A3-A2-gt-A4-，该关系模式属于第几范式？" class="headerlink" title="设关系模式R(U,F), U=(A1, A2, A3, A4}, 函数依赖集F=(A1-&gt;A2, A1-›A3, A2-&gt;A4}，该关系模式属于第几范式？"></a>设关系模式R(U,F), U=(A1, A2, A3, A4}, 函数依赖集F=(A1-&gt;A2, A1-›A3, A2-&gt;A4}，该关系模式属于第几范式？</h5><p>首先，让我们回顾一下各个范式的定义：</p><ul><li>第一范式（1NF）：关系中的每个属性都是原子的，不可再分。（列不可分）</li><li>第二范式（2NF）：在1NF的基础上，关系中的非主键属性完全依赖于主键，不存在部分依赖（这是限制联合索引的部分依赖情况）。</li><li>第三范式（3NF）：在2NF的基础上，关系中的非主键属性不存在传递依赖，即不存在非主键属性依赖于其他非主键属性。</li></ul><p>现在，我们来判断给定的关系模式R(U,F)属于哪个范式。</p><p>首先，我们检查是否满足第一范式（1NF）。在这个关系模式中，每个属性都是原子的，没有多值属性，所以满足1NF。</p><p>接下来，我们检查是否满足第二范式（2NF）。要判断2NF，我们需要找到候选码。在这个关系模式中，A1 是候选码（它是唯一的，并且确定了整个元组），因为 A1-&gt; A2 和 A1 -&gt; A3。</p><p>因为 A1 是候选码，并且 A2 和 A3 完全依赖于候选码 A1，不存在部分依赖。所以这个关系模式满足2NF。</p><p>最后，我们检查是否满足第三范式（3NF）。在这个关系模式中，A2 和 A4 存在传递依赖：A1 -&gt; A2 和 A2 -&gt; A4，从而得到 A1 -&gt; A4。所以，这个关系模式不满足3NF。</p><p>综上所述，这个关系模式R(U,F)属于第二范式（2NF）。它满足1NF和2NF，但不满足3NF。</p><h5 id="常见的反规范化技术有哪些？"><a href="#常见的反规范化技术有哪些？" class="headerlink" title="常见的反规范化技术有哪些？"></a>常见的反规范化技术有哪些？</h5><p>冗余列、派生列、重组表、水平分割表、垂直分割表。</p><h5 id="哪一种是指增加的列可以通过表中其他数据计算生成。它的作用是在查询时减少计算量，从而加快查询速度。"><a href="#哪一种是指增加的列可以通过表中其他数据计算生成。它的作用是在查询时减少计算量，从而加快查询速度。" class="headerlink" title="哪一种是指增加的列可以通过表中其他数据计算生成。它的作用是在查询时减少计算量，从而加快查询速度。"></a>哪一种是指增加的列可以通过表中其他数据计算生成。它的作用是在查询时减少计算量，从而加快查询速度。</h5><ol start="2"><li>派生列。</li></ol><h5 id="哪种是按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。"><a href="#哪种是按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。" class="headerlink" title="哪种是按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。"></a>哪种是按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用。</h5><p>水平分割表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开启此系列，为架构之常见问答，学以记录。&lt;/p&gt;
&lt;h5 id=&quot;局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？&quot;&gt;&lt;a href=&quot;#局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？&quot; class=&quot;headerlink&quot; title=&quot;局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？&quot;&gt;&lt;/a&gt;局部ER图转换成全局ER图时需要消除冲突，冲突的类型有几种，分别是什么？&lt;/h5&gt;
    
    </summary>
    
      <category term="架构" scheme="http://www.fancyga.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="http://www.fancyga.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300726-天道不一定酬勤，但天道一定酬勤</title>
    <link href="http://www.fancyga.com/2023/07/26/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300726-%E5%A4%A9%E9%81%93%E4%B8%8D%E4%B8%80%E5%AE%9A%E9%85%AC%E5%8B%A4%EF%BC%8C%E4%BD%86%E5%A4%A9%E9%81%93%E4%B8%80%E5%AE%9A%E9%85%AC%E5%8B%A4/"/>
    <id>http://www.fancyga.com/2023/07/26/每日札记-202300726-天道不一定酬勤，但天道一定酬勤/</id>
    <published>2023-07-26T01:15:00.000Z</published>
    <updated>2023-07-26T01:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天听到罗翔的一个观点：人一旦相信天道酬勤，很容易走向骄傲。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/7eb1723ef12b4c0db77fdfb8996155cd.jpeg" class="full-image"><a id="more"></a><p>上图为最近获取的证书，也因为此才作此文。</p><p>获取这个证书说实话不容易，学习了好久，背了好几轮，但由于疫情，考试托了很久。然后考试时，题型跟想象中的不大一样，很多题很迷惑，题量大且长，时间根本不够。</p><p>最后考下来是觉得没希望的，没想到后面居然过了，真的验证了那句话，你要是勤奋，老天都会帮你，心诚则灵。</p><p>不能不说有一定的道理，从一个侧面反映，天道酬勤这个词，我们理解是比较片面的。</p><p>罗翔的观点可能是：一个人相信天道酬勤，他成功以后，就取笑别人不勤奋，殊不知，有时候，人生还是靠些运气，靠些人脉，靠些天赋，这些因素不能忽略。</p><p>一句话：天时地利人和。</p><p>这个从侧面来验证了我们观点的前半部分，即天道不一定酬勤。</p><p>那么后半句话什么意思呢？其实就类似于：钱不是万能的，但没钱万万不能。就是说，天道酬的一定是勤劳的，如果你懒惰，门都不会让你进。</p><p>纵使你再有才华，如果不勤劳，一样会走向失败，这就是天道一定酬勤的含义。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天听到罗翔的一个观点：人一旦相信天道酬勤，很容易走向骄傲。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/7eb1723ef12b4c0db77fdfb8996155cd.jpeg&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300725-十赌十输</title>
    <link href="http://www.fancyga.com/2023/07/25/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300725-%E5%8D%81%E8%B5%8C%E5%8D%81%E8%BE%93/"/>
    <id>http://www.fancyga.com/2023/07/25/每日札记-202300725-十赌十输/</id>
    <published>2023-07-25T08:15:00.000Z</published>
    <updated>2023-07-25T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨日在某平台上看到有个赌徒，说自己输了将近400万。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/15fccd3396064dc48e4f889c72ce82a1.jpeg" class="full-image"><a id="more"></a><p>赌徒的心理是复杂的，总想一把把输掉的赢回来，可是，有个成语叫十赌九输。</p><p>现在看来这个词害人不浅，应该叫<strong>十赌十输</strong>，赌，到最后都是会输掉并负债，不会收手，因为人的本性是贪婪的，无法满足。</p><p>一些无良广告，也是害人，什么期权投资、P2P投资、联合养殖，都是一些人敛财的手段，这些没有严令禁止，是对国民的损害。</p><p>在中国，金融什么的都极其不完善，这些东西就不应该存在，玩到最后，受伤的都是普罗大众，只会以非吸收场。</p><p>前几天看了本书，讲赌王何鸿燊的，令人惊讶的是，作为赌王，竟然没有赌过，这就是真理，最大的赢家就是开赌场的人，不管你输你赢，他都有抽水，赌场就是他的造富工具。</p><p>何鸿燊的一生比较传奇，他的家族本来是香港有名望的，本过着富家子弟的生活，成绩也是倒数。但到他十几岁的时候，何鸿燊的父亲何世光和叔伯们被人下套买股票，结果家道中落。</p><p>何鸿燊从此奋发图强，改变了命运。所以，他的家族就是被赌博陷害的，所以他一生从不赌博，老一辈给了他反面教材，最后促使他走向家族的复兴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨日在某平台上看到有个赌徒，说自己输了将近400万。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/15fccd3396064dc48e4f889c72ce82a1.jpeg&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300724-创业环境之我见</title>
    <link href="http://www.fancyga.com/2023/07/24/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300724-%E5%88%9B%E4%B8%9A%E7%8E%AF%E5%A2%83%E4%B9%8B%E6%88%91%E8%A7%81/"/>
    <id>http://www.fancyga.com/2023/07/24/每日札记-202300724-创业环境之我见/</id>
    <published>2023-07-24T08:15:00.000Z</published>
    <updated>2023-07-24T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在的创业环境非常之不好。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/ae6b5fe90f5d448f9ea5ebf2598f9e34.jpeg" class="full-image"><a id="more"></a><p>可能10年前，一批人，会抓住互联网的趋势，没啥大阻碍地成长起来。可是现在真的挺难了。</p><p>现在听到的一个最多的词是：卷。各行各业都比较卷。我所处的IT行业更是如此。</p><p>10年前，可能你稍微背点面试题就能通过，稍微用心准备的，可能就进大厂了。现在真的是竞争惨烈。铺天盖地的面试宝典，不断地提升面试难度的上限。好多都是提升到源码细节的题。</p><p>为什么这两年这么卷呢？一方面工作机会少了，另一方面毕业生人数越来越多。</p><p>好多人是逼不得已去创业的，结局就是惨不忍睹，大多都以失败告终，负债累累。</p><p>如果说十年前难创业，现在就是更艰难。抖音这些社交性质软件，带来了一些机会，但同时，剥夺了很多创业的先天性环境。信息太容易获得，也太庞杂，大众都被导向一个方向，结果就导致那个方向的路堵死。</p><p>在这种繁杂环境下，又滋生了一批收割的骗子。他们不做实际事情，专门盯着你口袋里的钱，让你交出来给他。这一方面损害了大众利益，另一方面搞臭了大环境。</p><p>我们可以看到，一些做事情都不会做的，会出来教你做事情，然后从你口袋里捞钱。</p><p>有本书叫《乌合之众》，大概意思就是讲个体融入群体后，会被群体淹没，是研究大众心理学的。我们在这样的环境，特别是信息如此庞杂并碎片化的时代，很容易被一些不良媒体引导，很容易让骗子得逞。</p><p>常看到一些自己都没创过业的人，出来教你创业，还美其名曰：帮助创业者。</p><p>你先帮你自己吧。别来收割创业者了，创业者本来就很难，还想着收割这些群体。</p><p>科技，靠的不是你吹我捧，靠的不是翻译外国的文章，看到别人融资多少多少万美元，靠的是真正拿出实力来，真正从科学技术上进行创新。</p><p>我们不应该倡导这种虚荣吹捧的氛围，而是要倡导科技创新的事情，如果你对科技创新没有半点贡献，就请闭嘴，别高谈阔论，错误引导大众。</p><p>人说：语不惊人死不休，这些媒体已经到了这种失去良知的地步，为了自己的舆论造势，不惜错误引导大众。</p><p>国人现在身处的环境非常之鱼龙混杂，有些人趁势得利，给大众制造焦虑，将国外翻译过来的思想，不加思索就硬塞给大家，致使大众失去了基本的判断，更加焦虑无头绪。这样的媒体，罪不可赦。</p><p>大家都浮躁起来，被这些所谓媒体导向死胡同，死一大片，到处哀鸿片野，如此恶性循环。这样工作机会自然就变少了很多，加之毕业生越来越多，无法消化完，大家自然就卷起来。</p><p>导致的一个情形是，大家为卷而卷。没有考虑到本来该重视的东西，本末倒置。创新，谈何创新，不存在的，卷，时间都不够，何来创新？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在的创业环境非常之不好。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/ae6b5fe90f5d448f9ea5ebf2598f9e34.jpeg&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300721-里面难做吗</title>
    <link href="http://www.fancyga.com/2023/07/21/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300721-%E9%87%8C%E9%9D%A2%E9%9A%BE%E5%81%9A%E5%90%97/"/>
    <id>http://www.fancyga.com/2023/07/21/每日札记-202300721-里面难做吗/</id>
    <published>2023-07-21T14:15:00.000Z</published>
    <updated>2023-07-21T14:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天中午下班，走到园区外的时候，遇到了个农民工。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/bb65c57e46814278b7be897c7d46dac9.png" class="full-image"><a id="more"></a><p>从高新兴大门走出来，看到地上放着有个打包，里面鼓鼓囊囊不知道装的什么，我开始还以为是宝贵的东西。旁边还有个桶，其他东西没细看。</p><p>忽然看到不远处板凳上坐着一个壮年小伙坐在那，看衣着好像不是在附近上班的。他好像也看了看我，我看不出来他是干啥的。</p><p>我走到我的摩托车前，用RFID卡刷了刷摩托车，忽然那位壮年小伙站起来，走过来笑着问我：</p><p>“大哥，这里面是做什么的呀？”</p><p>我看了看他，觉得他这么问很奇怪，笑着说：</p><p>“做软件，另外做智能硬件的”</p><p>他似乎有些作羡慕状，问：</p><p>“好不好做呀”</p><p>我霎时间可以猜到他是做什么的了。</p><p>微笑着说：</p><p>“这看人的，学习了就会，不学就比较难”</p><p>然后骑车车走了。路上思绪万千，可以看得出，小伙挺上进，挺愿意学习，可是，由于一些外在条件（文化水平等），他被限制在了他现在的地方。</p><p>我只能帮他到这，意思是让他去学习。</p><p>农民工，真的有万般无奈，有时候，并不是不上进，而是被环境限制住了。</p><p>或者说，还没达到突破的程度，人生就这样被限制了。</p><p>我刚出社会的时候，何尝不是这样。那时候真的啥都不会，然后只能抱着个大砖头回家，自己啃知识。</p><p>当时学了很多知识，不仅仅学写代码，还学了设计，学了公司管理，甚至销售。</p><p>就是在这样不可能的条件下，我走上了刚离开学校的梦寐以求的路，做一个在高大写字楼里面的高端IT人才。</p><p>现在何尝不是这样的状况。我只是五十步看百步而已，现在做的工作，也就是高级农民工，尚未达到突破阶层。</p><p>要想革命，还得加大努力，这样才有可能走向想要的方向。</p><p>环境是一方面，但是，成功的人没有借口，我们只是努力得还不够，还不足以迎接那个该属于自己的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天中午下班，走到园区外的时候，遇到了个农民工。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/bb65c57e46814278b7be897c7d46dac9.png&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300719-话说健身房</title>
    <link href="http://www.fancyga.com/2023/07/19/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300719-%E8%AF%9D%E8%AF%B4%E5%81%A5%E8%BA%AB%E6%88%BF/"/>
    <id>http://www.fancyga.com/2023/07/19/每日札记-202300719-话说健身房/</id>
    <published>2023-07-19T01:44:00.000Z</published>
    <updated>2023-07-19T01:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>说下健身房的现状。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/504358b45f904048a3f73f1e429e5b43.jpeg" class="full-image"><a id="more"></a><p>我自己是从21年开始办的健身卡，健身的原因可能跟被人有些不一样。</p><p>当时受到了各方面的多重打击，自己已经不再坚持原来自我，尝试改变。原来根本没想过办健身卡，觉得浪费钱，在家练就行。可事情往往是这样，从没在家练。</p><p>受了打击之后，想尝试改变，于是就办了健身卡。当时办的好像是2000块半年，我去的第一家健身房还是比较高档的。也是没得选，附件的就那家。</p><p>后面去的基本上是2000就能顶一年，甚至到后来一千多一年。</p><p>通过近三年的时间感受，觉得办这个健身卡，肯定是值的。</p><p>第一，可以锻炼身体；第二，可以放松放松心情，在不一样的环境，而不是一直待在家。第三，就是健身房一般都有洗澡间，这个可以充分利用，下班以后过去锻炼，顺便洗个澡，然后回家，感觉较好。</p><p>健身房从各方面来讲是比较好的。但我也遇到了些不愉快的，也从别人的经历那里了解到一些不愉快。</p><p>毕竟有人的地方就有江湖。首先如果你影响到了他们私教的生意，或者影响到了器械，他们会过来说你。而且态度是越来越不把客人当客人。</p><p>甚至有些主管眼里，除了私教课成员，其他都不是客人，来了就要服从他的安排，非常让人作呕。</p><p>譬如我最近这家健身房，首先是沙袋太硬，叫他换不换，还附带命令的口吻，分明就是不想让你去打。这个健身房又小，他们又把那个打沙袋的房间封起来，说是不要影响私教课成员。</p><p>看如下这张图：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/d91602cbfa124f89b25fb345fa7ffd02.jpeg" class="full-image"><p>试问这种只服务于私教课学员的健身房，能走远吗？我对这家健身房印象非常差，叫什么<strong>鸿星健身连锁</strong>，跟骗子连锁一样。说好换店不收费的，结果还外收了500，进去了发现很讨厌，还不如不办。</p><p>如果没有地方，就想办法腾出地方来，而不是压缩普通会员的空间；没有资金就不要盲目扩招。这样的做法，只会另我们这些普通会员作呕。我们是去锻炼，不是去受你约束这约束那的，如果你想约束，干脆把健身房关了退钱，别再忽悠人进来了。</p><p>健身房遇到不爽的人是有的，但是大多情况下是大家互不干涉，都是去锻炼的。有时候也遇到些好教练，会在旁边指点你，不管他出于什么目的，他们都是比较和善的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说下健身房的现状。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/504358b45f904048a3f73f1e429e5b43.jpeg&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300714-工作中如何调节心态</title>
    <link href="http://www.fancyga.com/2023/07/14/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300714-%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%A6%82%E4%BD%95%E8%B0%83%E8%8A%82%E5%BF%83%E6%80%81/"/>
    <id>http://www.fancyga.com/2023/07/14/每日札记-202300714-工作中如何调节心态/</id>
    <published>2023-07-14T02:00:00.000Z</published>
    <updated>2023-07-14T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作这么多年，无论是自己实操过，或是自己看到过，高低有自己的一些见解。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/38781f0d110740a394bf977599ec435a.png" class="full-image"><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作这么多年，无论是自己实操过，或是自己看到过，高低有自己的一些见解。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/38781f0d110740a394bf977599ec435a.png&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>八股之十</title>
    <link href="http://www.fancyga.com/2023/07/14/%E5%85%AB%E8%82%A1%E4%B9%8B%E5%8D%81/"/>
    <id>http://www.fancyga.com/2023/07/14/八股之十/</id>
    <published>2023-07-14T01:45:00.000Z</published>
    <updated>2023-07-14T01:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发编程的特性：可见性、有序性和原子性分别介绍一下？"><a href="#并发编程的特性：可见性、有序性和原子性分别介绍一下？" class="headerlink" title="并发编程的特性：可见性、有序性和原子性分别介绍一下？"></a>并发编程的特性：可见性、有序性和原子性分别介绍一下？</h3><blockquote><p>原子性</p></blockquote><p>是指在一次或者多次操作时，要么所有操作都被执行，要么所有操作都不执行。</p><a id="more"></a><p>注意：</p><ul><li>多个原子性的操作合在一起不一定是原子性的。比如：<code>i++</code>就不是原子性的。</li><li><code>volatile</code>不能保证原子性，<code>synchronized</code>关键字能保证。</li><li>Java当中具有原子性的变量有：<code>AtomicInteger</code>、<code>AtomicLong</code>。</li><li>Java中，为了保证原子性，提供了两个高级的字节码指令<code>monitorenter</code>和<code>monitorexit</code>。</li></ul><blockquote><p>可见性</p></blockquote><p>是指一个线程对共享变量的修改能够被其他线程立即看到的特性。</p><ul><li><code>volatile</code>可以保证可见性。</li><li><code>synchronized</code>也可以保证可见性。</li><li>使用<code>Lock</code>相关的工具类可保证可见性。</li></ul><p>对于<code>volatile</code>变量，当对其进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中，而其他处理器的缓存由于遵守了缓存一致性协议，会把这个变量的值从主存加载到自己的缓存中， 这就保证了其值在多个缓存中是可见的。</p><p><code>synchronized</code>能够保证同一时刻只有一个线程获得锁，并确保在锁释放前，会把变量的修改刷到主存中。</p><blockquote><p>有序性</p></blockquote><p>所谓有序是针对<strong>指令重排</strong>来说的。</p><p>背景：在Java中，为了提高程序运行效率，可能在编译期和运行期会对代码指令进行一定的优化，不会保证代码执行顺序严格按照编写代码的顺序执行。</p><p>比如如下例子：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread one</span></span><br><span class="line">A = b + c</span><br><span class="line">D = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread two</span></span><br><span class="line">if(D) &#123;</span><br><span class="line">    System.out.println(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：Thread one将A、D共享变量从主内存复制到当前CPU内核的多级缓存中，按顺序执行完<code>A = b + c</code>和<code>D = true</code>后，多级缓存中A = 2，D = true。然后 Thread one将D的值<code>优先同步</code>到主缓存，A的值没有同步到主缓存。此时Thread two执行，能看到D的最新值true，却不能看到A的最新值，只能看到主缓存中A的初始值0。</p><ul><li><code>volatile</code>可通过<strong>内存屏障</strong>（Java中的内存屏障是一种CPU指令，可以防止CPU对指令序列进行重排序）来禁止指令重排，保证有序性。</li><li><code>synchronized</code>可以保证同一时刻只允许一个线程操作，因而当然可以保证多线程之间操作的有序性。</li></ul><h3 id="内存模型、主内存、工作内存？"><a href="#内存模型、主内存、工作内存？" class="headerlink" title="内存模型、主内存、工作内存？"></a>内存模型、主内存、工作内存？</h3><p>Java的内存模型，即JMM（Java Memory Model），就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p>Java内存模型规定了所有的变量都存储在<strong>主内存</strong>中，每条线程还有自己的<strong>工作内存</strong><br>，线程的工作内存中保存了该线程中使用到的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存中进行，而不能直接读写主内存。线程间变量的传递均需要自己的工作内存和主存之间进行数据同步。</p><h3 id="可见性的问题为什么会出现？"><a href="#可见性的问题为什么会出现？" class="headerlink" title="可见性的问题为什么会出现？"></a>可见性的问题为什么会出现？</h3><p>可见性是说：一个线程对共享变量的修改，其他线程能够立马看到。</p><p>这个在单核时代不是问题，因为各线程用的都是同一个CPU缓存。但在多核时代这个问题出现了，因为多核用的是不同核下的CPU缓存，这涉及到了缓存一致性的问题。</p><h3 id="操作系统级别有没有可见性的问题？原子性问题是怎么发生的？为什么会被打断？"><a href="#操作系统级别有没有可见性的问题？原子性问题是怎么发生的？为什么会被打断？" class="headerlink" title="操作系统级别有没有可见性的问题？原子性问题是怎么发生的？为什么会被打断？"></a>操作系统级别有没有可见性的问题？原子性问题是怎么发生的？为什么会被打断？</h3><p>操作系统级别也有可见性问题，这是由于多核CPU的多级缓存引起的，缓存间的数据也会产生数据不一致的问题。原子性的问题发生是由于CPU时间片机制。</p><p>比如，一个线程在执行<code>读改写</code>操作，在执行完<code>读改</code>之后，因为CPU还要顾及到其他线程执行，有不同的调度机制，该线程就被打断，让出了CPU给其他线程执行，在这个情况下，完整的<code>读改写</code>就被分割了，不是一个原子操作。</p><h3 id="加锁的过程是怎么同时保证三个特性的？锁的时间片丢了怎么办，有影响吗？"><a href="#加锁的过程是怎么同时保证三个特性的？锁的时间片丢了怎么办，有影响吗？" class="headerlink" title="加锁的过程是怎么同时保证三个特性的？锁的时间片丢了怎么办，有影响吗？"></a>加锁的过程是怎么同时保证三个特性的？锁的时间片丢了怎么办，有影响吗？</h3><p>加锁可以保证原子性，因为同一时刻只有一个线程操作，其他线程都是被阻塞，直到锁释放。这样该线程内执行的语句就可以保证原子性了，不会被其他线程干扰。</p><p>当一个线程获取到锁并修改了共享变量的值后，其他线程获取锁之前会重新读取到该共享变量的最新值，从而可以保证可见性。</p><p>加锁可以保证只有一个线程执行，这样该线程内的操作，顺序与代码的顺序是一致的，从而保证有序性。</p><p>锁的时间片丢了怎么办？丢了不会影响到三个特性，因为其他线程都是阻塞状态。但是时间片丢失会影响并发性，因为其他线程可能需要等待更长时间才能获得锁。</p><p>因此在设计和使用锁的过程中，需要考虑锁的粒度、持有时间等要素，平衡线程的竞争和系统的响应性能。</p><p>一般来说，锁会有个升级的过程，应根据情况自动调整锁等级。下面的问题详细回答。</p><h3 id="synchronized会加内存屏障吗？synchronized锁的是什么？一定是对象吗？锁的是对象的什么东西呢？对-class加锁锁的是什么？"><a href="#synchronized会加内存屏障吗？synchronized锁的是什么？一定是对象吗？锁的是对象的什么东西呢？对-class加锁锁的是什么？" class="headerlink" title="synchronized会加内存屏障吗？synchronized锁的是什么？一定是对象吗？锁的是对象的什么东西呢？对.class加锁锁的是什么？"></a>synchronized会加内存屏障吗？synchronized锁的是什么？一定是对象吗？锁的是对象的什么东西呢？对.class加锁锁的是什么？</h3><p><code>synchronized</code>的有序性是依靠内存屏障实现的，在<code>monitorenter</code>指令和<code>Load</code>屏障之后，会加一个<code>Acquire</code>屏障，这个屏障的作用是禁止同步代码块里面的读操作和外面的读写操作之间发生指令重排。</p><p><code>synchronized</code>锁有分<code>对象锁</code>和<code>类锁</code>，对.class加锁锁的是类，就是属于<code>类锁</code>。</p><p>对象锁有如下：</p><ol><li>锁住实体里的非静态变量</li><li>锁住<code>this</code>对象</li><li>直接锁非静态方法</li></ol><p>类锁有如下：</p><ol><li>锁类中的静态变量</li><li>锁住<code>.class</code></li><li>直接锁静态方法</li></ol><p>由于类对象也就是<code>Class</code>对象也是一个对象，所以说<code>synchronized</code>锁的一定是对象。</p><p>那锁的是对象的什么东西呢？</p><p>既然是对对象加锁，我们来看下对象的结构。<code>HotSpot</code>虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。其中锁的信息都是存在对象头的<code>Mark Word</code>中的。结构如下：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/358b09e1fb7c48359c3c0a0f84c4b156.jpeg" class="full-image"><p>在JDK1.6以及之前的版本中，<code>synchronized</code>锁是通过对象内部的一个叫<code>监视器锁</code>（也称对象锁）来实现的，这种锁是<strong>重量级锁</strong>，因为获取锁和释放锁都需要在操作系统层面上进行线程的阻塞和唤醒，这些操作会带来很大开销。</p><p>在JDK1.6之后，<code>synchronized</code>锁的实现发生了一些变化，引入了<strong>偏向锁</strong>、<strong>轻量级锁</strong>和<strong>重量级锁</strong>三种不同状态，来适应不同场景下的锁竞争情况。</p><p>所以，在Java中，锁的状态分为四种，分别是无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。在Java中，<code>Mark Word</code>的低两位用于表示锁的状态，由于无锁状态和偏向锁都是01，所以在低三位引入偏向锁标记位.用”0”表示无锁，”1”表示偏向锁。</p><p><code>synchronized</code>锁有个升级的过程：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/1ba8304a31794a45b29146e78c448275.jpeg" class="full-image"><p>各个锁的优缺点比较图：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/f365394073ad448aaeb46b55c8375a64.webp" class="full-image"><blockquote><p>无锁</p></blockquote><p>初始状态下，对象处于无锁状态，多个线程可并发执行。</p><blockquote><p>偏向锁</p></blockquote><p>当一个线程来访问一个对象的同步块时，JVM会在对象头中设置该线程的标识，并将对象头的状态位设置为<code>偏向锁</code>。</p><p>这个过程称为<code>偏向</code>，表示偏向第一个访问它的线程。</p><p>这个锁实际上并没有真正的加锁，因为这时候只有一个线程，没必要加一把大锁，它只是将自己的线程标识贴在<code>Mark Word</code>上，做个标记，为后续准备。</p><blockquote><p>轻量级锁</p></blockquote><p>当有其他线程来访时，会检查该对象的偏向锁标识，如果和自己的线程标识相同，则直接获取锁，如果不同则该对象的锁状态就会升级到轻量级锁状态。</p><p>轻量级锁使用CAS（所以又叫自旋锁）操作来进行加锁和解锁，避免了线程阻塞和唤醒的开销。</p><blockquote><p>重量级锁</p></blockquote><p>轻量级锁自旋如果成功了，则表示获取到了锁，可继续执行，如果失败了，表示存在竞争，则需要膨胀为重量级锁。</p><p>此时，如果一个线程想要获取改对象的锁，需要先进入等待队列，等待该锁被释放。当锁释放时，JVM会从等待队列中选择一个线程唤醒。</p><p>重量级锁使用操作系统的互斥量（Mutex）来实现线程的阻塞和唤醒。当线程无法获取重量级锁时，会进入阻塞状态，直到锁被释放或者唤醒。</p><blockquote><p>锁的升级过程是由JVM自动管理的，开发者无需手动介入。JVM会根据具体的执行情况和竞争情况来选择适当的锁级别，以提供最佳的性能和线程安全性。</p></blockquote><blockquote><p>轻量级锁什么时候升级重量级锁？</p></blockquote><p>JDK1.6之前，有线程CAS转圈超过10卷或者多个线程在等待(超过cpu/2个线程)会升级，参数可配置。JDK1.6之后，自适应，jvm内部会调整。</p><blockquote><p>有了轻量级锁为什么还要重量级锁？</p></blockquote><p>轻量级锁是利用自旋CAS实现，如果大量线程CAS也比较耗CPU，这是就要用到重量级锁，没锁就等着就行。</p><blockquote><p>什么情况下不用经过偏向锁直接升级到轻量级锁？</p></blockquote><p>偏向锁默认启动，上锁一般是在对象创建之后4秒之后加上，为什么是4秒？因为留4秒是给JVM启动会进行相关数据加载、协调进程同步的资源等。如果发现这个对象将会被多个线程进行访问，则没有必要上偏向锁了，直接上轻量级锁。</p><h3 id="CyclicBarrier和CountdownLatch区别？Java中还有哪些类基于CAS实现的？"><a href="#CyclicBarrier和CountdownLatch区别？Java中还有哪些类基于CAS实现的？" class="headerlink" title="CyclicBarrier和CountdownLatch区别？Java中还有哪些类基于CAS实现的？"></a>CyclicBarrier和CountdownLatch区别？Java中还有哪些类基于CAS实现的？</h3><p><code>CyclicBarrier</code>类似一个屏障，到达后等待着，等其他都到达一个同步点后再一起继续运行。<code>CountDownLatch</code>类似于倒计时，等待若干个线程执行完之后，再继续执行。</p><p>JDK提供了一系列基于CAS（Compare-And-Swap）实现的原子类，底层是<code>lock cmpxchfg</code>指令，可以保证比较交换的原子性，所以这些原子类都是线程安全的，而且是无锁并发，线程不会频繁切换，所以在某些场景下性能是优于加锁。</p><p>主要有以下类型：</p><ol><li>基础类型原子类，如<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code></li><li>原子引用类，如<code>AtomicReference</code>，由于可能出现<code>ABA</code>问题（一个线程将A改为B，之后又改回A，这是后另外一个线程没法感知第一个线程的变化，仍然认为A不变，可以执行交换），所以出现了带版本的<code>AtomicStampedReference</code>，又由于有时候并不关心共享变量改了几次，而只是标记下是否发生过改变，加个标记即可，因而会有<code>AtomicMarkableReference</code>。</li><li>原子更新器，如<code>AtomicReferenceFieldUpdater</code>、<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>。注：原子字段更新器只能更新<code>volatile</code>字段，他可以保证可见性，但无法保证原子性。</li><li>原子数组类，如<code>AtomicIntegerArray</code>等。</li><li>原子累加器，如<code>LongAdder</code>等。</li></ol><h3 id="Atomic是什么场景下使用？和LongAdder区别？为什么不精确还要用呢？"><a href="#Atomic是什么场景下使用？和LongAdder区别？为什么不精确还要用呢？" class="headerlink" title="Atomic是什么场景下使用？和LongAdder区别？为什么不精确还要用呢？"></a>Atomic是什么场景下使用？和LongAdder区别？为什么不精确还要用呢？</h3><p><code>Atomic</code>适用于多线程高并发下对单个变量进行原子操作的场景。例如计数器、标记位等。它通过使用底层的CAS操作，避免使用锁带来的性能开销，提供了更高效的并发操作。</p><p><code>LongAdder</code>是Java 8引入的原子累加器，性能比<code>AtomicLong</code>好，因为提供了多个累加单元，最后才将结果汇总，这样多线程在累加时操作不同的单元，减少了CAS重试失败操作，提高性能。</p><p>正式由于使用了多个累加单元的分段累加策略，减少CAS，所以可能会出现计数不准确的情况，但在大多数情况下，这种误差可以接受。为什么还用它，当然是因为它较高效些，要进行性能和精确的权衡。</p><h3 id="RPC和HTTP的区别？为什么RPC会比HTTP效率高？"><a href="#RPC和HTTP的区别？为什么RPC会比HTTP效率高？" class="headerlink" title="RPC和HTTP的区别？为什么RPC会比HTTP效率高？"></a>RPC和HTTP的区别？为什么RPC会比HTTP效率高？</h3><p>RPC（Remote Procedure Call）和HTTP（Hypertext Transfer Protocol）是两种不同的通信协议，它们在设计和用途上有一些区别。</p><ol><li><p>功能和用途：</p><ul><li>RPC：RPC是一种用于实现远程过程调用的协议，它允许程序在不同的计算机或进程之间进行通信和调用。RPC可以用于构建分布式系统，实现不同节点之间的方法调用和数据交换。</li><li>HTTP：HTTP是一种用于传输超文本的协议，它主要用于在客户端和服务器之间传递请求和响应。HTTP通常用于构建基于Web的应用程序，通过请求和响应的方式获取和传输数据。</li></ul></li><li><p>通信方式：</p><ul><li>RPC：RPC通信是面向方法调用的，客户端可以直接调用远程服务端的方法，并获取返回结果。通信过程通常使用二进制协议，数据传输更加高效。</li><li>HTTP：HTTP通信是面向请求和响应的，客户端发送请求到服务器，并等待服务器返回响应。通信过程基于文本，包含请求头、请求体、响应头和响应体，相对于RPC的通信量较大。</li></ul></li><li><p><strong>序列化和反序列化</strong>：</p><ul><li>RPC：RPC通信中，数据的序列化和反序列化通常使用高效的二进制序列化方式，如Protocol Buffers、Thrift等，可以实现更快的数据传输和解析。</li><li>HTTP：HTTP通信中，数据的序列化和反序列化通常使用文本格式，如JSON、XML等，相对于二进制序列化会有一定的性能开销。</li></ul></li></ol><p>为什么RPC会比HTTP效率高呢？主要有以下几个方面的原因：</p><ul><li>二进制协议：RPC通信使用高效的<strong>二进制协议</strong>，减少了数据的序列化和反序列化的开销，同时它传的都是干货，减少了请求和响应的数据量和处理的开销。</li><li>连接的复用：RPC服务是基于TCP/IP协议的长连接，而HTTP服务大都是短连接，虽然HTTP1.1开始支持长连接，但也需要看服务端是否支持长连接，不太可控。</li></ul><p>需要注意的是，RPC和HTTP并不是完全互斥的，它们在不同的场景和需求下有各自的优势和适用性。RPC更适用于构建高性能、低延迟的分布式系统，而HTTP更适用于构建面向Web的应用程序，并提供了更广泛的兼容性和互操作性。</p><h3 id="JVM类加载机制？"><a href="#JVM类加载机制？" class="headerlink" title="JVM类加载机制？"></a>JVM类加载机制？</h3><blockquote><p>概述</p></blockquote><p>首先，在代码编译后，就会生成JVM能够识别的二进制字节流文件（*.class）。</p><p>接着Class文件从加载到JVM内存到卸载，经历了如下阶段：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/03c08675c0274a6ca6bd40391188fc13.jpeg" class="full-image"><p>其中类加载机制指的是前面五个阶段，即包括加载、连接和初始化，其中连接包括验证、准备和解析，各个过程如下描述：</p><blockquote><p>加载</p></blockquote><p>查找并加载类的二进制数据（网络，jar包，运行时生成等），将类的.class文件中的二进制数据放入内存中，将其放在方法区中，然后在内存中创建一个<code>java.lang.Class</code>对象（方法区）。</p><blockquote><p>连接</p></blockquote><ol><li>验证：确保被加载的类的正确性（确保Class文件的字节流符合虚拟机的要求）。</li><li>准备：为类的静态变量分配内存并设置初始化值（通常为数据类型的零值，注意不是用户指定值）。另外，静态常量（<code>final static</code>修饰的），会在这个阶段初始化为用户指定值。</li><li>解析：主要将类、接口、字段和方法的符号引用转换为直接引用。（符号引用是一组符号来描述所引用的目标，而直接引用是指向目标的指针、偏移量或其他表示形式，与具体的内存地址相关。）</li></ol><blockquote><p>初始化</p></blockquote><p>这个阶段主要是执行了编译器整合的一个方法<code>cinit</code>，其里面进行了两个操作：1. 初始化静态变量（前面的连接时候并没有给静态变量设置用户指定值，这时指定）；2. 静态块执行。</p><ul><li><code>cinit</code>不一定生成，如果没有静态代码块或静态变量，那么编译器不会生成这个方法。</li><li>虚拟机会保证父类的<code>cinit</code>方法先执行，不需要像<code>init</code>方法一样显示地调用父类构造器来保证父类init方法执行完成。</li><li>这里用了一种懒加载的思想，所有Java虚拟机要这样实现：必须在每个类或接口被Java程序首次主动使用才初始化。</li></ul><blockquote><p>初始化时机</p></blockquote><ul><li>当遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时，比如<code>new</code>一个类，读取个静态字段(未被<code>final</code>修饰)或调用一个类的静态方法时。</li><li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>JVM启动时标明的启动类。</li></ul><p>每个Java类都有一个对应的类加载器，Java默认的类加载机制是双亲委派机制。</p><blockquote><p>类加载器</p></blockquote><ol><li>启动类加载器</li></ol><p>启动类加载器是C++实现的，JVM中最顶级的类加载器，主要加载Java平台的核心库（JAVA_HOME/jre/lib/rt.jar）中的类，如java.lang.Object和java.lang.String等。</p><ol start="2"><li>扩展类加载器</li></ol><p>由<code>sun.misc.Launcher$ExtClassLoader</code>实现，主要加载扩展类（JAVA_HOME/jre/lib/ext/<em>.jar），或java.ext.dirs指定的路径中的所有类库（如javax.</em>开头的类），其父类加载器是启动类加载器。</p><ol start="3"><li>应用程序类加载器</li></ol><p>由<code>sun.misc.Launcher$AppClassLoader</code>实现，负责加载应用程序类路径（classpath）下的类。，其父类加载器是扩展类加载器。（注意父子关系是组合关系，而非继承关系）</p><ol start="4"><li>自定义加载器</li></ol><p>通过继承java.lang.ClassLoader实现自定义加载器。</p><p>类加载大致流程如下：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/0d6e5cf6f5f544459255b711b04edf7c.png" class="full-image"><p>这就是所谓的<code>双亲委派模型</code>（Parents Delegation Mode），即除最顶层的启动类加载器，其余的类加载器都应由自己的父类加载器尝试先加载，加载不到后再从自身加载。</p><p>这样的模型有两个好处：</p><ul><li>确保Java核心类库都不会被篡改，比如用户如果编写java.lang.Object，不能让其覆盖系统的。</li><li>防止内存中存在多份同样的字节码。</li></ul><p>双亲委派模型主要由<code>ClassLoader#loadClass</code>实现，其是线程安全的，因为里面用了<code>synchronized</code>加锁，要想破坏这个模型，只需要自定义类加载器并重写<code>loadClass</code>方法，做些处理即可。</p><h3 id="有哪些破坏双亲委派的例子？Tomcat为啥要破坏双亲委派？为什么打破双亲委派就能实现隔离？如果公用的类怎么办？"><a href="#有哪些破坏双亲委派的例子？Tomcat为啥要破坏双亲委派？为什么打破双亲委派就能实现隔离？如果公用的类怎么办？" class="headerlink" title="有哪些破坏双亲委派的例子？Tomcat为啥要破坏双亲委派？为什么打破双亲委派就能实现隔离？如果公用的类怎么办？"></a>有哪些破坏双亲委派的例子？Tomcat为啥要破坏双亲委派？为什么打破双亲委派就能实现隔离？如果公用的类怎么办？</h3><blockquote><p>破坏双亲委派的例子</p></blockquote><ol><li>SPI</li></ol><p>SPI（Service Provider Interface），其核心思想是：依赖倒置，将具体的实现给外部实现。SPI的接口是Java核心库的一部分，由启动类加载；而实现类是由系统类加载器来完成加载。</p><p>启动类加载器是无法找到SPI的实现类的（因为它只加载Java核心库），按照双亲委派模型无法解决这个问题，唯一的办法就是破坏它。</p><p>比如JNDI、JDBC等SPI就是这样的例子。怎么破坏呢？</p><p>Java设计团队引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread的<code>setContextClassLoader</code>方法进行设置。如果没设置，就是默认的应用程序类加载器。</p><p>有了这个机制，就可以处理这个问题了。这实际上违背了双亲委派模型，但解决了这个SPI问题。</p><p>比如JDBC的驱动加载<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code>就是利用了这种机制：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;</span><br><span class="line">    <span class="comment">// 用的Thread Context ClassLoader</span></span><br><span class="line">    ClassLoader cl = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">ContextClassLoader()</span>;</span><br><span class="line">    return <span class="module-access"><span class="module"><span class="identifier">ServiceLoader</span>.</span></span>load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>模块化</li></ol><p>模块化，是为了实现热插拔，热部署，用到这个特性：只需要将模块连同类加载器一起换掉，就可以实现代码的热替换。（一个类要想被卸载，必须要其相应<code>ClassLoader</code>实例卸载）</p><p>比如JDK9，已经支持了模块化机制，不会直接委派给父类加载器加载，而是按照模块的维度来划分类加载器，只有模块中找不到该类，才会采用双亲委派机制。</p><ol start="3"><li>TOMCAT</li></ol><p>我们先来看TOMCAT作为一个WEB容器，需要支持的特性：</p><ul><li>可能需要部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个容器只有一份，因此需要保证每个应用程序都是独立的，相互隔离的。</li><li>部署在同一个容器中相同类库的相同版本可以共享，否则，多份相同的类库加载进虚拟机，浪费。</li><li>容器有自己依赖的库，不能与应用程序的类库混淆，两者隔离开来。</li><li>容器要支持不需要重启的JSP的修改，所谓<strong>热替换</strong>。</li></ul><p>然后我们看看双亲委派模型能不能支持以上特性。显然不行。</p><ul><li>第一点，双亲委派机制是无法加载两个相同类库的不同版本的，它只在乎你的全限定类名，只有一份。</li><li>第二点可以满足，因为默认机制就是保证唯一性。</li><li>第三点和第一点一样的问题。</li><li>第四点，其实就是需要改造成类似上面的模块化的方案。</li></ul><p>第四点解决就是，我们卸载JSP时，和其类加载器一同卸载，这样达到重新加载JSP的目的。</p><p>Tomcat是怎么设计类加载机制的呢？可看下图：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/af6785b8c91f64775daa4f2d0631c0f9.png" class="full-image"><p>可以看到，前面3个类加载器和默认的是一样的。</p><ul><li>CommonClassLoader，加载/common/*</li><li>CatalinaClassLoader，加载/server/*</li><li>SharedClassLoader，加载/shared/*</li></ul><blockquote><p>以上三个加载器在tomcat6后合并到根目录下的lib目录下，即<tomcat>/lib/*.jar</tomcat></p></blockquote><ul><li>WebappClassLoader，通常有多个，每个WEB应用程序对应一个，加载<webapp>/WEB-INF/classes和<webapp>/WEB-INF/lib/*.jar</webapp></webapp></li><li>JasperLoader，每一个JSP文件对应一个JSP类加载器。</li></ul><p>可以看出，CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。</p><p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个应用WebAppClassLoader实例之间相互隔离。</p><p>JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，当容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的JasperLoader来实现JSP文件的热替换功能。</p><h3 id="加载后的类会立即初始化吗？内存的开辟是怎么做的？开辟多大的内存呢？内存分配过程会有线程安全问题吗？"><a href="#加载后的类会立即初始化吗？内存的开辟是怎么做的？开辟多大的内存呢？内存分配过程会有线程安全问题吗？" class="headerlink" title="加载后的类会立即初始化吗？内存的开辟是怎么做的？开辟多大的内存呢？内存分配过程会有线程安全问题吗？"></a>加载后的类会立即初始化吗？内存的开辟是怎么做的？开辟多大的内存呢？内存分配过程会有线程安全问题吗？</h3><h3 id="JVM本地方法区里面都有什么？常量存在哪？字符串常量池？字符串中的常量什么时候进入常量池的？运行时常量池和字符串池是一回事吗？"><a href="#JVM本地方法区里面都有什么？常量存在哪？字符串常量池？字符串中的常量什么时候进入常量池的？运行时常量池和字符串池是一回事吗？" class="headerlink" title="JVM本地方法区里面都有什么？常量存在哪？字符串常量池？字符串中的常量什么时候进入常量池的？运行时常量池和字符串池是一回事吗？"></a>JVM本地方法区里面都有什么？常量存在哪？字符串常量池？字符串中的常量什么时候进入常量池的？运行时常量池和字符串池是一回事吗？</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;并发编程的特性：可见性、有序性和原子性分别介绍一下？&quot;&gt;&lt;a href=&quot;#并发编程的特性：可见性、有序性和原子性分别介绍一下？&quot; class=&quot;headerlink&quot; title=&quot;并发编程的特性：可见性、有序性和原子性分别介绍一下？&quot;&gt;&lt;/a&gt;并发编程的特性：可见性、有序性和原子性分别介绍一下？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;原子性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是指在一次或者多次操作时，要么所有操作都被执行，要么所有操作都不执行。&lt;/p&gt;
    
    </summary>
    
      <category term="八股文" scheme="http://www.fancyga.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
      <category term="八股文" scheme="http://www.fancyga.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>八股之九</title>
    <link href="http://www.fancyga.com/2023/07/14/%E5%85%AB%E8%82%A1%E4%B9%8B%E4%B9%9D/"/>
    <id>http://www.fancyga.com/2023/07/14/八股之九/</id>
    <published>2023-07-13T16:05:00.000Z</published>
    <updated>2023-07-13T16:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="调支付渠道失败了怎么办？"><a href="#调支付渠道失败了怎么办？" class="headerlink" title="调支付渠道失败了怎么办？"></a>调支付渠道失败了怎么办？</h3><ol><li>检查错误信息。</li><li>重试机制，可以设置最大重试次数和时间间隔。</li><li>错误处理和回退策略。</li><li>监控和报警。</li></ol><a id="more"></a><h3 id="同一个订单的多个回调如何处理？"><a href="#同一个订单的多个回调如何处理？" class="headerlink" title="同一个订单的多个回调如何处理？"></a>同一个订单的多个回调如何处理？</h3><ol><li>幂等性处理：在设计回调接口时，考虑幂等性，可以通过在数据库中记录订单处理状态或生成唯一的回调标识来实现幂等。</li><li>队列机制：将回调请求放入消息队列，然后使用消费者进行消费处理。</li><li>异步处理：将回调请求异步处理，使用线程池处理，提高系统的并发处理能力。</li></ol><h3 id="幂等的问题一定要通过加锁来做吗？利用流水怎么来做幂等？如果已经用了分布式锁，流水表还需要做唯一性约束吗？"><a href="#幂等的问题一定要通过加锁来做吗？利用流水怎么来做幂等？如果已经用了分布式锁，流水表还需要做唯一性约束吗？" class="headerlink" title="幂等的问题一定要通过加锁来做吗？利用流水怎么来做幂等？如果已经用了分布式锁，流水表还需要做唯一性约束吗？"></a>幂等的问题一定要通过加锁来做吗？利用流水怎么来做幂等？如果已经用了分布式锁，流水表还需要做唯一性约束吗？</h3><p>幂等问题不一定通过加锁来做，可以通过下面方式：</p><p>幂等性指的是，对于同一笔业务操作，不管调用多少次，得到的结果是一样的。</p><p>幂等可以通过以下几个方式：</p><blockquote><p>普通方式</p></blockquote><p>这种就是根据唯一标识查看当前操作是否处理过，处理过就直接返回。</p><p>缺点：如果多次同时调用，多次到查询这一步都是未处理的，都执行了，产生问题。</p><blockquote><p>JVM加锁</p></blockquote><p>就是在处理请求的时候进行加锁。又叫单体锁（synchronized或ReentrantLock）</p><p>缺点：如果只有一台服务器，当然这个可以，但是对于集群方式，显然有问题。</p><blockquote><p>悲观锁方式</p></blockquote><p>这种方式是使用数据库的悲观锁实现。使用<code>select ... for update</code>来实现。这个语句只有在事务提交之后才会释放锁，其他就只能先等着。类似Java中Lock。</p><p>缺点：可能会造成大量等待线程，不利于并发。</p><blockquote><p>乐观锁方式</p></blockquote><p>这种方式会利用数据库<code>update ... where column = xxx</code>来实现乐观锁，更新成功则提交事务，失败则回滚事务。类似Java中的CAS操作。</p><p>可以这么做的原因：数据内部会保证update同一条记录会排队执行，最终最有一条update会执行成功。</p><blockquote><p>唯一约束方式</p></blockquote><p>可以创建一张流水表，表中的唯一标识具有唯一约束。</p><p>这样在事务最后，可执行插入一条该次请求唯一标识的记录，插入成功则提交事务，失败则回滚。</p><p>这就是利用数据库的唯一标识来处理。</p><blockquote><p>分布式锁方式</p></blockquote><p>可通过第三方（如redis、zookeeper），在调用时先获取分布式锁，完后进行释放。</p><p>这种方式保证同一时间只有一个线程能够执行次方法，当然就是幂等的。</p><blockquote><p>如果已经用了分布式锁，流水表还需要做唯一性约束吗？需要，因为要确保分布式锁失效的情况。</p></blockquote><h3 id="分布式事务什么场景用，TCC是什么？"><a href="#分布式事务什么场景用，TCC是什么？" class="headerlink" title="分布式事务什么场景用，TCC是什么？"></a>分布式事务什么场景用，TCC是什么？</h3><p>常见分布式事务使用场景举例：</p><blockquote><p>支付</p></blockquote><p>最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，要么全部失败。而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。</p><blockquote><p>在线下单</p></blockquote><p>买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。</p><p>TCC是什么呢？</p><p>TCC一种分布式事务解决方案，它的全称为Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel）。由若干分支事务组成的，每个分支都要求实现Try、Confirm、Cancel。有两阶段，其中第一阶段Try，第二阶段Confirm或Cancel。注意事项：</p><ol><li>每个TCC步骤是幂等的</li></ol><p>无论是网络数据包重传，还是异常事务的补偿执行，都会导致TCC服务的Try、Confirm或者Cancel操作被重复执行；用户在实现TCC服务时，需要考虑幂等控制，即Try、Confirm、Cancel 执行次和执行多次的业务结果是一样的。</p><ol start="2"><li>允许空回滚</li></ol><p>第一阶段Try可能超时，这时候会触发第二阶段Cancel，即空回滚。</p><ol start="3"><li>防悬挂控制</li></ol><p>因为允许空回滚，空回滚之后，第一阶段的Try由于网络拥堵，后面才到，这就要求Try可以比Cancel后执行，即要做到防悬挂控制。</p><p>TCC大体框架如下：</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/2070a87fcf5f4c64bf8c81ccddab17c0.jpeg" class="full-image"><blockquote><p>题外</p></blockquote><p>分布式事务解决方案有：</p><ol><li>两阶段提交（2PC）两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</li><li>补偿事务（TCC），就是前文讲的TCC。</li><li>本地消息表（异步确保）</li><li>MQ事务消息（RocketMQ)</li></ol><p>解决分布式事务的框架有：<code>SEATA</code></p><h3 id="TCC的cancel也失败了怎么办？TCC的优缺点？"><a href="#TCC的cancel也失败了怎么办？TCC的优缺点？" class="headerlink" title="TCC的cancel也失败了怎么办？TCC的优缺点？"></a>TCC的cancel也失败了怎么办？TCC的优缺点？</h3><p>TCC可以做事务⽇志，如果Confirm或者Cancel阶段出错，则会进⾏重试，所以这两个阶段需要⽀持幂等。如果重试失败，则需要⼈⼯介⼊进⾏恢复和处理等。</p><blockquote><p>优点：</p></blockquote><ul><li>解决了跨服务的业务操作原子性问题，例如组合支付，订单减库存等场景非常实用。</li><li>TCC的本质原理是把数据库的二阶段提交上升到微服务来实现，从而避免了数据库两阶段中锁冲突的长事务低性能风险。</li><li>TCC异步高性能，它采用了try先检查，然后异步实现confirm，真正提交的是在confirm方法中。</li></ul><blockquote><p>缺点：</p></blockquote><ul><li>对微服务的侵入性强，微服务的每个事务都必须实现try，confirm，cancel等3个方法，开发成本高，今后维护改造的成本也高。</li><li>为了达到事务的一致性要求，try，confirm、cancel接口必须实现等幂性操作。（定时器 + 重试）</li><li>由于事务管理器要记录事务日志，必定会损耗一定的性能，并使得整个TCC事务时间拉长，建议采用redis的方式来记录事务日志。</li></ul><h3 id="RocketMQ如何保证顺序性？消费者如何保证先消费M1后消费M2？"><a href="#RocketMQ如何保证顺序性？消费者如何保证先消费M1后消费M2？" class="headerlink" title="RocketMQ如何保证顺序性？消费者如何保证先消费M1后消费M2？"></a>RocketMQ如何保证顺序性？消费者如何保证先消费M1后消费M2？</h3><p>如上图所示，其实就是多MQ服务和多消费者的情况下怎么保证消费顺序的问题。就是要有机制能保证M1和M2都发送到一个MQ服务，并且都在一个消费者成功进行消费。如果M1没有消费成功，则要重试，可以发送给另外一个消费者，如果M1成功了再发M2。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/634a1a4cc00a4b558e103a510dce78bf.jpeg" class="full-image"><p>那有一个问题，由于存在重试，所以可能会出现重复消息，这就要求消息消费要具有幂等性。</p><p>备注：RocketMQ通过MessageQueueSelector中实现的算法来确定消息发送到哪一个队列上。比如我们同一个orderId的M1和M2，经算法计算后肯定落到同一个队列上。</p><h3 id="消息中间件能解决什么问题？消息的推拉模型？实时性？推的模式还能削峰填谷吗？如何用拉实现推？怎么知道拉多少消息合适？第一次拉多少合适？"><a href="#消息中间件能解决什么问题？消息的推拉模型？实时性？推的模式还能削峰填谷吗？如何用拉实现推？怎么知道拉多少消息合适？第一次拉多少合适？" class="headerlink" title="消息中间件能解决什么问题？消息的推拉模型？实时性？推的模式还能削峰填谷吗？如何用拉实现推？怎么知道拉多少消息合适？第一次拉多少合适？"></a>消息中间件能解决什么问题？消息的推拉模型？实时性？推的模式还能削峰填谷吗？如何用拉实现推？怎么知道拉多少消息合适？第一次拉多少合适？</h3><p>消息中间件解决问题如下：</p><ol><li>解耦：可以将发送者和接受者解耦，使他们不需要直接进行通信。</li><li>可靠性：消息中间件通常具有可靠性保证机制，可以确保消息的可靠传递。</li><li>异步通信：消息中间件支持异步通信模型，发送者可以快速将消息发送到中间件，而不需要等待接收者的及时响应。</li><li>削峰填谷：通过消息中间件的缓冲和流量控制机制，可以实现削峰填谷的效果。</li></ol><p>消息推拉模型是指消息的传递方式。实时性来说，推的模式比较高，拉模式较低。</p><p>使用拉模型实现推模型可以通过轮询的方式进行。接受者定时从消息中间件拉取一定数量的消息。</p><p>第一次拉多少消息合适，可以根据业务需求和系统的处理能力来决定。可以设置个合适的初始值，然后根据系统响应速度和负载情况进行动态调整。</p><h3 id="如何让接口RT变得更小？"><a href="#如何让接口RT变得更小？" class="headerlink" title="如何让接口RT变得更小？"></a>如何让接口RT变得更小？</h3><p>优化接口响应时间主要有如下思路：</p><ol><li>本地缓存（如Guava等）</li><li>分布式缓存</li><li>并行化</li><li>异步化</li><li>池化技术</li><li>分库分表</li><li>SQL优化</li><li>预先计算</li><li>事务相关</li><li>海量数据处理</li><li>批量读写</li><li>锁的粒度</li><li>上下文传递</li><li>空间大小</li><li>查询优化</li></ol><h3 id="Redis怎么实现分布式锁？"><a href="#Redis怎么实现分布式锁？" class="headerlink" title="Redis怎么实现分布式锁？"></a>Redis怎么实现分布式锁？</h3><p>如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(redisTemplate.ops<span class="constructor">ForValue()</span>.set<span class="constructor">IfAbsent(REDIS_LOCK, <span class="params">value</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置过期时间，防止突然宕机不能释放锁</span></span><br><span class="line">    redisTemplate.expire(REDIS_LOCK, timeout, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 业务代码</span></span><br><span class="line">... </span><br><span class="line"><span class="comment">// 执行完后释放锁</span></span><br><span class="line">redisTemplate.delete(REDIS_LOCK);</span><br></pre></td></tr></table></figure><p>这里有个问题，就是可能还没执行完，但是到期了，锁自动释放了，解决办法是锁续期，可以使用<code>Redission</code>框架（其原理是只要线程加锁成功，就会启动有个看门狗，它是后台一个线程，每隔10秒检查下，如果线程还持有锁，就会给锁续期。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;调支付渠道失败了怎么办？&quot;&gt;&lt;a href=&quot;#调支付渠道失败了怎么办？&quot; class=&quot;headerlink&quot; title=&quot;调支付渠道失败了怎么办？&quot;&gt;&lt;/a&gt;调支付渠道失败了怎么办？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;检查错误信息。&lt;/li&gt;
&lt;li&gt;重试机制，可以设置最大重试次数和时间间隔。&lt;/li&gt;
&lt;li&gt;错误处理和回退策略。&lt;/li&gt;
&lt;li&gt;监控和报警。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="八股文" scheme="http://www.fancyga.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
      <category term="八股文" scheme="http://www.fancyga.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300713-公司管理之我见</title>
    <link href="http://www.fancyga.com/2023/07/13/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300713-%E5%85%AC%E5%8F%B8%E7%AE%A1%E7%90%86%E4%B9%8B%E6%88%91%E8%A7%81/"/>
    <id>http://www.fancyga.com/2023/07/13/每日札记-202300713-公司管理之我见/</id>
    <published>2023-07-13T02:00:00.000Z</published>
    <updated>2023-07-13T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作这么多年，无论是自己实操过，或是自己看到过，高低有自己的一些见解。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/55995d5e25b541b3801b939f44818731.png" class="full-image"><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作这么多年，无论是自己实操过，或是自己看到过，高低有自己的一些见解。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/55995d5e25b541b3801b939f44818731.png&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>八股之八</title>
    <link href="http://www.fancyga.com/2023/07/13/%E5%85%AB%E8%82%A1%E4%B9%8B%E5%85%AB/"/>
    <id>http://www.fancyga.com/2023/07/13/八股之八/</id>
    <published>2023-07-13T01:44:00.000Z</published>
    <updated>2023-07-13T01:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？"><a href="#EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？" class="headerlink" title="EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？"></a>EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？</h3><p>EasyExcel是在POI基础上开发的。POI有个缺陷就是比较耗内存（POI有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如有些版本解压缩以及解压后存储都是在内存中完成的，内存消耗比较大），EasyExcel很好解决了这个问题，在读写大文件的时候使用磁盘做缓存，更加的节约内存。</p><p>另外EasyExcel用注解的方式映射excel和实体，简单易用。数据校对如时间格式，可以用注解在字段上限制。</p><p>下面是一个例子：</p><a id="more"></a><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    @Data</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelData</span> &#123;</span></span><br><span class="line">        @ExcelProperty(<span class="string">"姓名"</span>)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">        @ExcelProperty(<span class="string">"年龄"</span>)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        @JsonFormat(</span><br><span class="line">                pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span></span><br><span class="line">        )</span><br><span class="line">        @ExcelProperty(value = <span class="string">"申请时间"</span>)</span><br><span class="line">        <span class="keyword">private</span> Date applyTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEasyExcel</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        List&lt;ExcelData&gt; tmpList = easyReadExcel();</span><br><span class="line">        <span class="keyword">for</span> (ExcelData excelData : tmpList)&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(excelData);</span><br><span class="line">        &#125;</span><br><span class="line">        writeExcel(tmpList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ExcelData&gt; <span class="title">easyReadExcel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> fileName = <span class="string">"&#123;文件路径&#125;"</span>;</span><br><span class="line">        <span class="comment">// 指定读用哪个class去读，然后读取第一个sheet(默认第一个，可传下标改变sheet页) 同步读取会自动finish</span></span><br><span class="line">        List&lt;ExcelData&gt; excelDataList = EasyExcel.<span class="built_in">read</span>(fileName)</span><br><span class="line">                .excelType(ExcelTypeEnum.XLSX)</span><br><span class="line">                .head(ExcelData.class)</span><br><span class="line">                .sheet()</span><br><span class="line">                .doReadSync();</span><br><span class="line">        <span class="keyword">return</span> excelDataList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeExcel</span><span class="params">(List&lt;ExcelData&gt; <span class="built_in">list</span>)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> fileName = <span class="string">"excelOutput.xlsx"</span>;</span><br><span class="line">        EasyExcel.<span class="built_in">write</span>(fileName, ExcelData.class).excelType(ExcelTypeEnum.CSV).sheet(<span class="string">"导出列表"</span>).doWrite(<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延时队列是什么？死信队列是什么？"><a href="#延时队列是什么？死信队列是什么？" class="headerlink" title="延时队列是什么？死信队列是什么？"></a>延时队列是什么？死信队列是什么？</h3><p>延时队列内部是有序的，延时队列就是用来存放需要在指定时间点被处理的元素的队列。</p><p>死信，顾名思义就是不能被消费的消息。Rabbitmq是通过死信队列（通过DLX和TTL）来实现延迟消息的（不管是AMQP协议还是RabbitMQ本身不支持）。</p><p>但有个问题就是由于队列排序问题，可能后面的比前面的早过期，但由于前面的没有消费所以不能消费，解决这个办法是有个Delayed Message插件。</p><h3 id="项目中的性能优化工具有哪些？"><a href="#项目中的性能优化工具有哪些？" class="headerlink" title="项目中的性能优化工具有哪些？"></a>项目中的性能优化工具有哪些？</h3><h3 id="HTTP调用占用内存？异步为什么能减少线程个数？netty，多路复用？"><a href="#HTTP调用占用内存？异步为什么能减少线程个数？netty，多路复用？" class="headerlink" title="HTTP调用占用内存？异步为什么能减少线程个数？netty，多路复用？"></a>HTTP调用占用内存？异步为什么能减少线程个数？netty，多路复用？</h3><h3 id="Netty线程模型，零拷贝技术？"><a href="#Netty线程模型，零拷贝技术？" class="headerlink" title="Netty线程模型，零拷贝技术？"></a>Netty线程模型，零拷贝技术？</h3><h3 id="缓存穿透、击穿、雪崩？"><a href="#缓存穿透、击穿、雪崩？" class="headerlink" title="缓存穿透、击穿、雪崩？"></a>缓存穿透、击穿、雪崩？</h3><h3 id="怎么做数据预热？"><a href="#怎么做数据预热？" class="headerlink" title="怎么做数据预热？"></a>怎么做数据预热？</h3><h3 id="Spring中的设计模式？"><a href="#Spring中的设计模式？" class="headerlink" title="Spring中的设计模式？"></a>Spring中的设计模式？</h3><h3 id="私有的构造西数怎么还能创建对象呢？"><a href="#私有的构造西数怎么还能创建对象呢？" class="headerlink" title="私有的构造西数怎么还能创建对象呢？"></a>私有的构造西数怎么还能创建对象呢？</h3><h3 id="BeanUtils是深拷贝还是浅拷贝？"><a href="#BeanUtils是深拷贝还是浅拷贝？" class="headerlink" title="BeanUtils是深拷贝还是浅拷贝？"></a>BeanUtils是深拷贝还是浅拷贝？</h3><h3 id="数据库的隔离级别有哪些？"><a href="#数据库的隔离级别有哪些？" class="headerlink" title="数据库的隔离级别有哪些？"></a>数据库的隔离级别有哪些？</h3><blockquote><p>读未提交</p></blockquote><blockquote><p>读提交（READ COMMITTED）</p></blockquote><blockquote><p>可重复读（REPEATED READ）</p></blockquote><p>MYSQL默认的隔离级别。</p><blockquote><p>序列化（SERIALIZABLE）</p></blockquote><p>最高的隔离级别，这种级别下，事务<strong>串行化顺序执行</strong>。这种级别下，<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>都可以被避免，但是执行效率差，基本没人会用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？&quot;&gt;&lt;a href=&quot;#EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？&quot; class=&quot;headerlink&quot; title=&quot;EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？&quot;&gt;&lt;/a&gt;EasyExcel和poi对比，耗内存？如何做用户上传的excel转成csv，有没有做数据校对？&lt;/h3&gt;&lt;p&gt;EasyExcel是在POI基础上开发的。POI有个缺陷就是比较耗内存（POI有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如有些版本解压缩以及解压后存储都是在内存中完成的，内存消耗比较大），EasyExcel很好解决了这个问题，在读写大文件的时候使用磁盘做缓存，更加的节约内存。&lt;/p&gt;
&lt;p&gt;另外EasyExcel用注解的方式映射excel和实体，简单易用。数据校对如时间格式，可以用注解在字段上限制。&lt;/p&gt;
&lt;p&gt;下面是一个例子：&lt;/p&gt;
    
    </summary>
    
      <category term="八股文" scheme="http://www.fancyga.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
      <category term="八股文" scheme="http://www.fancyga.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>八股之七</title>
    <link href="http://www.fancyga.com/2023/07/12/%E5%85%AB%E8%82%A1%E4%B9%8B%E4%B8%83/"/>
    <id>http://www.fancyga.com/2023/07/12/八股之七/</id>
    <published>2023-07-12T14:19:00.000Z</published>
    <updated>2023-07-12T14:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么叫单点登录，单点登录如何实现？能实现跨域吗？"><a href="#什么叫单点登录，单点登录如何实现？能实现跨域吗？" class="headerlink" title="什么叫单点登录，单点登录如何实现？能实现跨域吗？"></a>什么叫单点登录，单点登录如何实现？能实现跨域吗？</h3><a id="more"></a><h3 id="token鉴权如何做到不能同时登录的呢？"><a href="#token鉴权如何做到不能同时登录的呢？" class="headerlink" title="token鉴权如何做到不能同时登录的呢？"></a>token鉴权如何做到不能同时登录的呢？</h3><h3 id="Mybatis如何分页？limit-offset-pageSize-逻辑分页还是物理分页？区别是什么？"><a href="#Mybatis如何分页？limit-offset-pageSize-逻辑分页还是物理分页？区别是什么？" class="headerlink" title="Mybatis如何分页？limit offset,pageSize ,逻辑分页还是物理分页？区别是什么？"></a>Mybatis如何分页？limit offset,pageSize ,逻辑分页还是物理分页？区别是什么？</h3><h3 id="MybatisPlus能干什么？有缺点吗？"><a href="#MybatisPlus能干什么？有缺点吗？" class="headerlink" title="MybatisPlus能干什么？有缺点吗？"></a>MybatisPlus能干什么？有缺点吗？</h3><h3 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h3><h3 id="公平锁和非公平锁有什么区别？优缺点？"><a href="#公平锁和非公平锁有什么区别？优缺点？" class="headerlink" title="公平锁和非公平锁有什么区别？优缺点？"></a>公平锁和非公平锁有什么区别？优缺点？</h3><h3 id="如何实现的锁重入？Countdownlatch，cyclicbarrier、semaphore区别是什么？"><a href="#如何实现的锁重入？Countdownlatch，cyclicbarrier、semaphore区别是什么？" class="headerlink" title="如何实现的锁重入？Countdownlatch，cyclicbarrier、semaphore区别是什么？"></a>如何实现的锁重入？Countdownlatch，cyclicbarrier、semaphore区别是什么？</h3><h3 id="Reentrant默认是公平还是非公平锁？想要实现公平怎么做？state的值只有可能是0和1吗？"><a href="#Reentrant默认是公平还是非公平锁？想要实现公平怎么做？state的值只有可能是0和1吗？" class="headerlink" title="Reentrant默认是公平还是非公平锁？想要实现公平怎么做？state的值只有可能是0和1吗？"></a>Reentrant默认是公平还是非公平锁？想要实现公平怎么做？state的值只有可能是0和1吗？</h3><h3 id="StringBuffer-StringBuilder区别？"><a href="#StringBuffer-StringBuilder区别？" class="headerlink" title="StringBuffer StringBuilder区别？"></a>StringBuffer StringBuilder区别？</h3><h3 id="常见的字符编码有哪些？UTF和Unicode关系？为啥还需要GBK？没啥英文字母不会出现乱码？"><a href="#常见的字符编码有哪些？UTF和Unicode关系？为啥还需要GBK？没啥英文字母不会出现乱码？" class="headerlink" title="常见的字符编码有哪些？UTF和Unicode关系？为啥还需要GBK？没啥英文字母不会出现乱码？"></a>常见的字符编码有哪些？UTF和Unicode关系？为啥还需要GBK？没啥英文字母不会出现乱码？</h3><h3 id="如何实现把一个对象转成JSON字符串？"><a href="#如何实现把一个对象转成JSON字符串？" class="headerlink" title="如何实现把一个对象转成JSON字符串？"></a>如何实现把一个对象转成JSON字符串？</h3><h3 id="数据库什么时候用float？"><a href="#数据库什么时候用float？" class="headerlink" title="数据库什么时候用float？"></a>数据库什么时候用float？</h3><h3 id="浏览器地址栏输出www-xx-com之后发生了什么事情？"><a href="#浏览器地址栏输出www-xx-com之后发生了什么事情？" class="headerlink" title="浏览器地址栏输出www.xx.com之后发生了什么事情？"></a>浏览器地址栏输出<a href="http://www.xx.com之后发生了什么事情？" target="_blank" rel="noopener">www.xx.com之后发生了什么事情？</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么叫单点登录，单点登录如何实现？能实现跨域吗？&quot;&gt;&lt;a href=&quot;#什么叫单点登录，单点登录如何实现？能实现跨域吗？&quot; class=&quot;headerlink&quot; title=&quot;什么叫单点登录，单点登录如何实现？能实现跨域吗？&quot;&gt;&lt;/a&gt;什么叫单点登录，单点登录如何实现？能实现跨域吗？&lt;/h3&gt;
    
    </summary>
    
      <category term="八股文" scheme="http://www.fancyga.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
      <category term="八股文" scheme="http://www.fancyga.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300712-话说半吊子</title>
    <link href="http://www.fancyga.com/2023/07/12/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300712-%E8%AF%9D%E8%AF%B4%E5%8D%8A%E5%90%8A%E5%AD%90/"/>
    <id>http://www.fancyga.com/2023/07/12/每日札记-202300712-话说半吊子/</id>
    <published>2023-07-12T01:44:00.000Z</published>
    <updated>2023-07-12T01:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>半吊子这个词，来源于古代，跟古钱币有关。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/21a2207318704a15996b4fd31a7a28ef.png" class="full-image"><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;半吊子这个词，来源于古代，跟古钱币有关。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/21a2207318704a15996b4fd31a7a28ef.png&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>八股之六</title>
    <link href="http://www.fancyga.com/2023/07/11/%E5%85%AB%E8%82%A1%E4%B9%8B%E5%85%AD/"/>
    <id>http://www.fancyga.com/2023/07/11/八股之六/</id>
    <published>2023-07-11T14:19:00.000Z</published>
    <updated>2023-07-11T14:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是数仓"><a href="#什么是数仓" class="headerlink" title="什么是数仓"></a>什么是数仓</h3><p>数据仓库全程为Data Warehouse，简称DW。它是面向主题的，集成的，相对稳定的，反应<strong>历史</strong>变化的数据存储集合，用于支撑企业的分析<strong>报告</strong>与决策。</p><h3 id="binLog的格式是怎样的？"><a href="#binLog的格式是怎样的？" class="headerlink" title="binLog的格式是怎样的？"></a>binLog的格式是怎样的？</h3><p>binLog有三种格式：</p><ul><li>Statement（Statement-Based Replication,SBR）：每一条会修改数据的SQL都会记录在binlog中。（由于存在函数如uuid，这样每次执行会不一样，所以会出现一致性问题）</li><li>Row（Row-Based Replication,RBR）：不记录SQL语句上下文信息，仅保存哪条记录被修改。（避免Statement问题，但在批量修改时，显然这种日志会比较大）</li><li>Mixed（Mixed-Based Replication,MBR）：Statement和Row的混合体。</li></ul><h3 id="MVCC主要解决那种情况下的并发？写写并发如何解决？"><a href="#MVCC主要解决那种情况下的并发？写写并发如何解决？" class="headerlink" title="MVCC主要解决那种情况下的并发？写写并发如何解决？"></a>MVCC主要解决那种情况下的并发？写写并发如何解决？</h3><h3 id="最左前缀匹配原则是什么？为什么要遵守这个原则？"><a href="#最左前缀匹配原则是什么？为什么要遵守这个原则？" class="headerlink" title="最左前缀匹配原则是什么？为什么要遵守这个原则？"></a>最左前缀匹配原则是什么？为什么要遵守这个原则？</h3><h3 id="联合索引构造出来的B-树长什么样子？"><a href="#联合索引构造出来的B-树长什么样子？" class="headerlink" title="联合索引构造出来的B+树长什么样子？"></a>联合索引构造出来的B+树长什么样子？</h3><h4 id="a-b-c联合索引，用b-c查询，一定不会走索引吗？不用a查询也能覆盖吗？"><a href="#a-b-c联合索引，用b-c查询，一定不会走索引吗？不用a查询也能覆盖吗？" class="headerlink" title="a,b,c联合索引，用b,c查询，一定不会走索引吗？不用a查询也能覆盖吗？"></a>a,b,c联合索引，用b,c查询，一定不会走索引吗？不用a查询也能覆盖吗？</h4><h3 id="a-b联合索引，如何索引覆盖。Select-b-from-table-where-a-xxx，走覆盖吗？Select-a-from-table-where-b-xxx，走覆盖吗？"><a href="#a-b联合索引，如何索引覆盖。Select-b-from-table-where-a-xxx，走覆盖吗？Select-a-from-table-where-b-xxx，走覆盖吗？" class="headerlink" title="a,b联合索引，如何索引覆盖。Select b from table where a = xxx，走覆盖吗？Select a from table where b = xxx，走覆盖吗？"></a>a,b联合索引，如何索引覆盖。Select b from table where a = xxx，走覆盖吗？Select a from table where b = xxx，走覆盖吗？</h3><p>不绝对！考虑mysql8.0索引跳跃扫描情况。</p><h3 id="什么情况会导致索引失效？"><a href="#什么情况会导致索引失效？" class="headerlink" title="什么情况会导致索引失效？"></a>什么情况会导致索引失效？</h3><ul><li>不满足最左前缀匹配原则</li></ul><h3 id="求无重复字符的最长子串：”abcabcbb”？"><a href="#求无重复字符的最长子串：”abcabcbb”？" class="headerlink" title="求无重复字符的最长子串：”abcabcbb”？"></a>求无重复字符的最长子串：”abcabcbb”？</h3><a id="more"></a><p>思路：</p><p>这种问题一般用双指针方法求解，即子串有个开始位置和结束位置，用两个指针标志位置。</p><p>就是求最长子串，那就穷举喽，子串肯定有个开始位置和结束位置，我们穷举子串的开始位置，这个就是暴力求解法，用C++实现如下：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; occ;</span><br><span class="line">        <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 答案</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 把上次开始位置字符删了</span></span><br><span class="line">                occ.erase(str[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不断地移动右指针，直到找到重复</span></span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.count(str[rk + <span class="number">1</span>])) &#123;</span><br><span class="line">                occ.insert(str[rk + <span class="number">1</span>]);</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第i到rk个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = fmax(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"abcabcbb"</span>;</span><br><span class="line">    <span class="keyword">int</span> result = solution.lengthOfLongestSubstring(str);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Length of longest substring without repeating characters: "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>这里用<code>unordered_set</code>是因为该数据结构能够在$O(1)$时间查到是否有某元素。</p><p>其实这里就是遍历子串开始位置，然后右指针不断扩张，扩到不能再扩，求得当前开始位置下的最长子串，通过遍历全部，得到整体最长子串。</p><p>此算法属于暴力求解，当然还有优化空间，就是<strong>开始位置</strong>不用每个位置都要去到：</p><ol><li>当发现重复之后，其实开始位置可以直接定位到<strong>已有元素中重复元素的下一位</strong>（因为前面一直到重复位，有指针都不能再增加）。</li><li>当发现最大长度大于从<strong>已有元素中重复元素的下一位</strong>到结束的长度，就可以直接返回（因为后面不管怎么变都不会超过这个长度了）。</li></ol><p>这种就是所谓的滑动窗口方法，滑动窗口可以用以解决数组/字符串的子元素相关问题，并且可以将嵌套的循环问题，转换为单循环问题，从而降低时间复杂度。</p><p>滑动窗口算法的复杂度一般为$O(n)$。上面的暴力求解法显然要经过两个循环，如上一个for一个while，复杂度为$(O(n^2))。</p><p>其实可以换个思路，可以不断向右扩展右指针，然后左指针发现重复后，向右滑动到重复的地方，这个就可以满足上面的优化条目1，</p><p>具体解法如下：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; uniCharMap;</span><br><span class="line">    <span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">        <span class="comment">// 重复后，比较最大值，可能左指针向右移动到之前记录的位置</span></span><br><span class="line">        <span class="keyword">if</span> (uniCharMap.<span class="built_in">find</span>(s[j]) != uniCharMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            i = <span class="built_in">std</span>::<span class="built_in">max</span>(uniCharMap[s[j]], i);</span><br><span class="line">        &#125;</span><br><span class="line">        maxLen = <span class="built_in">std</span>::<span class="built_in">max</span>(maxLen, j - i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 优化点2，后面的子串肯定超过不了当前最大值，不必再看</span></span><br><span class="line">        <span class="keyword">if</span> (len - i + <span class="number">1</span> &lt; maxLen) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录当前对应的下一个位置</span></span><br><span class="line">        uniCharMap[s[j]] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是数仓&quot;&gt;&lt;a href=&quot;#什么是数仓&quot; class=&quot;headerlink&quot; title=&quot;什么是数仓&quot;&gt;&lt;/a&gt;什么是数仓&lt;/h3&gt;&lt;p&gt;数据仓库全程为Data Warehouse，简称DW。它是面向主题的，集成的，相对稳定的，反应&lt;strong&gt;历史&lt;/strong&gt;变化的数据存储集合，用于支撑企业的分析&lt;strong&gt;报告&lt;/strong&gt;与决策。&lt;/p&gt;
&lt;h3 id=&quot;binLog的格式是怎样的？&quot;&gt;&lt;a href=&quot;#binLog的格式是怎样的？&quot; class=&quot;headerlink&quot; title=&quot;binLog的格式是怎样的？&quot;&gt;&lt;/a&gt;binLog的格式是怎样的？&lt;/h3&gt;&lt;p&gt;binLog有三种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Statement（Statement-Based Replication,SBR）：每一条会修改数据的SQL都会记录在binlog中。（由于存在函数如uuid，这样每次执行会不一样，所以会出现一致性问题）&lt;/li&gt;
&lt;li&gt;Row（Row-Based Replication,RBR）：不记录SQL语句上下文信息，仅保存哪条记录被修改。（避免Statement问题，但在批量修改时，显然这种日志会比较大）&lt;/li&gt;
&lt;li&gt;Mixed（Mixed-Based Replication,MBR）：Statement和Row的混合体。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MVCC主要解决那种情况下的并发？写写并发如何解决？&quot;&gt;&lt;a href=&quot;#MVCC主要解决那种情况下的并发？写写并发如何解决？&quot; class=&quot;headerlink&quot; title=&quot;MVCC主要解决那种情况下的并发？写写并发如何解决？&quot;&gt;&lt;/a&gt;MVCC主要解决那种情况下的并发？写写并发如何解决？&lt;/h3&gt;&lt;h3 id=&quot;最左前缀匹配原则是什么？为什么要遵守这个原则？&quot;&gt;&lt;a href=&quot;#最左前缀匹配原则是什么？为什么要遵守这个原则？&quot; class=&quot;headerlink&quot; title=&quot;最左前缀匹配原则是什么？为什么要遵守这个原则？&quot;&gt;&lt;/a&gt;最左前缀匹配原则是什么？为什么要遵守这个原则？&lt;/h3&gt;&lt;h3 id=&quot;联合索引构造出来的B-树长什么样子？&quot;&gt;&lt;a href=&quot;#联合索引构造出来的B-树长什么样子？&quot; class=&quot;headerlink&quot; title=&quot;联合索引构造出来的B+树长什么样子？&quot;&gt;&lt;/a&gt;联合索引构造出来的B+树长什么样子？&lt;/h3&gt;&lt;h4 id=&quot;a-b-c联合索引，用b-c查询，一定不会走索引吗？不用a查询也能覆盖吗？&quot;&gt;&lt;a href=&quot;#a-b-c联合索引，用b-c查询，一定不会走索引吗？不用a查询也能覆盖吗？&quot; class=&quot;headerlink&quot; title=&quot;a,b,c联合索引，用b,c查询，一定不会走索引吗？不用a查询也能覆盖吗？&quot;&gt;&lt;/a&gt;a,b,c联合索引，用b,c查询，一定不会走索引吗？不用a查询也能覆盖吗？&lt;/h4&gt;&lt;h3 id=&quot;a-b联合索引，如何索引覆盖。Select-b-from-table-where-a-xxx，走覆盖吗？Select-a-from-table-where-b-xxx，走覆盖吗？&quot;&gt;&lt;a href=&quot;#a-b联合索引，如何索引覆盖。Select-b-from-table-where-a-xxx，走覆盖吗？Select-a-from-table-where-b-xxx，走覆盖吗？&quot; class=&quot;headerlink&quot; title=&quot;a,b联合索引，如何索引覆盖。Select b from table where a = xxx，走覆盖吗？Select a from table where b = xxx，走覆盖吗？&quot;&gt;&lt;/a&gt;a,b联合索引，如何索引覆盖。Select b from table where a = xxx，走覆盖吗？Select a from table where b = xxx，走覆盖吗？&lt;/h3&gt;&lt;p&gt;不绝对！考虑mysql8.0索引跳跃扫描情况。&lt;/p&gt;
&lt;h3 id=&quot;什么情况会导致索引失效？&quot;&gt;&lt;a href=&quot;#什么情况会导致索引失效？&quot; class=&quot;headerlink&quot; title=&quot;什么情况会导致索引失效？&quot;&gt;&lt;/a&gt;什么情况会导致索引失效？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不满足最左前缀匹配原则&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;求无重复字符的最长子串：”abcabcbb”？&quot;&gt;&lt;a href=&quot;#求无重复字符的最长子串：”abcabcbb”？&quot; class=&quot;headerlink&quot; title=&quot;求无重复字符的最长子串：”abcabcbb”？&quot;&gt;&lt;/a&gt;求无重复字符的最长子串：”abcabcbb”？&lt;/h3&gt;
    
    </summary>
    
      <category term="八股文" scheme="http://www.fancyga.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
      <category term="八股文" scheme="http://www.fancyga.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>每日札记-202300711-生活节奏</title>
    <link href="http://www.fancyga.com/2023/07/11/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0-202300711-%E7%94%9F%E6%B4%BB%E8%8A%82%E5%A5%8F/"/>
    <id>http://www.fancyga.com/2023/07/11/每日札记-202300711-生活节奏/</id>
    <published>2023-07-11T06:16:00.000Z</published>
    <updated>2023-07-11T06:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作换了好几个地方，有些地方是比较适合生活节奏的，有些地方明显不行。</p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/4dba5a0d89a641ba9d8a11faa76d039d.png" class="full-image"><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作换了好几个地方，有些地方是比较适合生活节奏的，有些地方明显不行。&lt;/p&gt;
&lt;img src=&quot;https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/4dba5a0d89a641ba9d8a11faa76d039d.png&quot; class=&quot;full-image&quot;&gt;
    
    </summary>
    
      <category term="每日札记" scheme="http://www.fancyga.com/categories/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="每日札记" scheme="http://www.fancyga.com/tags/%E6%AF%8F%E6%97%A5%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
</feed>
